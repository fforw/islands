var Demo =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonpDemo"] = window["webpackJsonpDemo"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./src/index.js","vendors"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "../organic-quads/lib/index.js":
/*!*************************************!*\
  !*** ../organic-quads/lib/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Vector\", {\n  enumerable: true,\n  get: function get() {\n    return _vector.default;\n  }\n});\nexports.default = exports.t_size = exports.t_tile3 = exports.t_tile2 = exports.t_tile1 = exports.t_tile0 = exports.t_isEdge = exports.t_n3 = exports.t_n2 = exports.t_n1 = exports.t_n0 = exports.g_size = exports.g_edge5 = exports.g_edge4 = exports.g_edge3 = exports.g_edge2 = exports.g_edge1 = exports.g_edge0 = exports.g_count = exports.g_isEdge = exports.g_y = exports.g_x = exports.f_size = exports.f_outmostEdge = exports.f_count = exports.f_y3 = exports.f_x3 = exports.f_y2 = exports.f_x2 = exports.f_y1 = exports.f_x1 = exports.f_y0 = exports.f_x0 = void 0;\n\nvar _performanceNow = _interopRequireDefault(__webpack_require__(/*! performance-now */ \"../organic-quads/node_modules/performance-now/lib/performance-now.js\"));\n\nvar _vector = _interopRequireDefault(__webpack_require__(/*! ./vector */ \"../organic-quads/lib/vector.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar f_x0 = 0;\nexports.f_x0 = f_x0;\nvar f_y0 = 1;\nexports.f_y0 = f_y0;\nvar f_x1 = 2;\nexports.f_x1 = f_x1;\nvar f_y1 = 3;\nexports.f_y1 = f_y1;\nvar f_x2 = 4;\nexports.f_x2 = f_x2;\nvar f_y2 = 5;\nexports.f_y2 = f_y2;\nvar f_x3 = 6;\nexports.f_x3 = f_x3;\nvar f_y3 = 7;\nexports.f_y3 = f_y3;\nvar f_count = 8;\nexports.f_count = f_count;\nvar f_outmostEdge = 9;\nexports.f_outmostEdge = f_outmostEdge;\nvar f_size = 10;\nexports.f_size = f_size;\nvar g_x = 0;\nexports.g_x = g_x;\nvar g_y = 1;\nexports.g_y = g_y;\nvar g_isEdge = 2;\nexports.g_isEdge = g_isEdge;\nvar g_count = 3;\nexports.g_count = g_count;\nvar g_edge0 = 4;\nexports.g_edge0 = g_edge0;\nvar g_edge1 = 5;\nexports.g_edge1 = g_edge1;\nvar g_edge2 = 6;\nexports.g_edge2 = g_edge2;\nvar g_edge3 = 7;\nexports.g_edge3 = g_edge3;\nvar g_edge4 = 8;\nexports.g_edge4 = g_edge4;\nvar g_edge5 = 9;\nexports.g_edge5 = g_edge5;\nvar g_size = 10;\nexports.g_size = g_size;\nvar t_n0 = 0;\nexports.t_n0 = t_n0;\nvar t_n1 = 1;\nexports.t_n1 = t_n1;\nvar t_n2 = 2;\nexports.t_n2 = t_n2;\nvar t_n3 = 3;\nexports.t_n3 = t_n3;\nvar t_isEdge = 4;\nexports.t_isEdge = t_isEdge;\nvar t_tile0 = 5;\nexports.t_tile0 = t_tile0;\nvar t_tile1 = 6;\nexports.t_tile1 = t_tile1;\nvar t_tile2 = 7;\nexports.t_tile2 = t_tile2;\nvar t_tile3 = 8;\nexports.t_tile3 = t_tile3;\nvar t_size = 9;\nexports.t_size = t_size;\nvar TAU = Math.PI * 2;\nvar SIXTH = TAU / 6;\n\nfunction calculateNumberOfFaces(limit) {\n  return 6 * (limit + 1) * (limit + 1);\n}\n\nvar DEFAULT_CONFIG = {\n  /** coordinate width */\n  width: 0,\n\n  /** coordinate height */\n  height: 0,\n\n  /** number of rings in the hexagon / number of base intersections of hexaxgon */\n  numberOfRings: 5,\n\n  /** how many percent of the edges shall we attempt to remove? */\n  removeEdges: 50,\n\n  /** if true, the graph will be layouted a bit with every render. If false, the graph relaxation happens at creation */\n  animatedEasing: true,\n\n  /** Set to true to render the original triangles, set to \"merged\" to render the merged triangles before subdivision */\n  renderFirstPassEdges: false,\n\n  /** Set to true to enable some debug logging */\n  debug: false,\n  weightFunction: function weightFunction(x0, y0, x1, y1) {\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n  /// MOSTLY INTERNAL CONFIG ////\n  // calculated internally to match the height\n  edgeLength: 80,\n  // number of iterations until we give up (we will drop out due to having reached low energy most likely much sooner)\n  maxIterations: 100,\n  // set to false if the graph is done animated on animatedEasing : true\n  animating: true,\n  // Minimum energy at which we stop relaxing the graph\n  minTension: 2\n};\n\nfunction updateConfig(config) {\n  config.numFaces = calculateNumberOfFaces(config.numberOfRings);\n  config.firstPassLen = config.numFaces * f_size;\n  config.firstPassNumEdges = config.numFaces * 3;\n  config.edgeLength = Math.min(config.width, config.height) / (config.numberOfRings * 2 + 2) | 0;\n  config.animating = config.animatedEasing;\n  config.relaxCount = 0;\n}\n\nfunction createHexagonTriangles(config) {\n  var limit = config.numberOfRings; //console.log(\"createHexagonTriangles\", limit);\n\n  var DIRECTIONS = [new _vector.default(Math.cos(0) * config.edgeLength, Math.sin(0) * config.edgeLength), new _vector.default(Math.cos(SIXTH) * config.edgeLength, Math.sin(SIXTH) * config.edgeLength), new _vector.default(Math.cos(SIXTH * 2) * config.edgeLength, Math.sin(SIXTH * 2) * config.edgeLength), new _vector.default(Math.cos(SIXTH * 3) * config.edgeLength, Math.sin(SIXTH * 3) * config.edgeLength), new _vector.default(Math.cos(SIXTH * 4) * config.edgeLength, Math.sin(SIXTH * 4) * config.edgeLength), new _vector.default(Math.cos(SIXTH * 5) * config.edgeLength, Math.sin(SIXTH * 5) * config.edgeLength)];\n  var faces = new Float64Array(config.firstPassLen);\n  var off = 0;\n  var count = 0;\n  var numTris = 1;\n\n  do {\n    for (var i = 0; i < 6; i++) {\n      var v0 = DIRECTIONS[i];\n      var v1 = DIRECTIONS[(i + 1) % 6];\n      var v2 = DIRECTIONS[(i + 2) % 6];\n      var pos = v0.copy().scale(count);\n\n      for (var j = 0; j < numTris; j++) {\n        if (j & 1) {\n          faces[off + f_x0] = pos.x | 0;\n          faces[off + f_y0] = pos.y | 0;\n          faces[off + f_x1] = pos.x + v1.x | 0;\n          faces[off + f_y1] = pos.y + v1.y | 0;\n          faces[off + f_x2] = pos.x + v2.x | 0;\n          faces[off + f_y2] = pos.y + v2.y | 0;\n          faces[off + f_count] = 3;\n          faces[off + f_outmostEdge] = -1;\n          off += f_size;\n          pos.add(v2);\n        } else {\n          // All tris in the last row all have their edge #1 on the outer edge of the big hexagon\n          var isOutmost = count === limit;\n          faces[off + f_x0] = pos.x | 0;\n          faces[off + f_y0] = pos.y | 0;\n          faces[off + f_x1] = pos.x + v0.x | 0;\n          faces[off + f_y1] = pos.y + v0.y | 0;\n          faces[off + f_x2] = pos.x + v1.x | 0;\n          faces[off + f_y2] = pos.y + v1.y | 0;\n          faces[off + f_count] = 3;\n          faces[off + f_outmostEdge] = isOutmost ? 1 : -1;\n          off += f_size;\n        }\n      }\n    }\n\n    numTris += 2;\n  } while (count++ < limit);\n\n  return faces;\n}\n\nfunction findOtherEdge(faces, x0, y0, x1, y1, index, out) {\n  for (var i = 0; i < faces.length; i += f_size) {\n    if (i === index) {\n      continue;\n    } // console.log(\"find\", x0, y0, x1, y1, \":\",\n    //     faces[i + f_x0], faces[i + f_y0],\n    //     faces[i + f_x1], faces[i + f_y1],\n    //     faces[i + f_x2], faces[i + f_y2],\n    //     faces[i + f_x3], faces[i + f_y3],\n    // );\n\n\n    var count = faces[i + f_count];\n\n    if (faces[i + f_x0] === x1 && faces[i + f_y0] === y1 && faces[i + f_x1] === x0 && faces[i + f_y1] === y0) {\n      out.index = i;\n      out.edge = 0;\n      return;\n    }\n\n    if (faces[i + f_x1] === x1 && faces[i + f_y1] === y1 && faces[i + f_x2] === x0 && faces[i + f_y2] === y0) {\n      out.index = i;\n      out.edge = 1;\n      return;\n    }\n\n    if (count === 3) {\n      if (faces[i + f_x2] === x1 && faces[i + f_y2] === y1 && faces[i + f_x0] === x0 && faces[i + f_y0] === y0) {\n        out.index = i;\n        out.edge = 2;\n        return;\n      }\n    } else {\n      if (faces[i + f_x2] === x1 && faces[i + f_y2] === y1 && faces[i + f_x3] === x0 && faces[i + f_y3] === y0) {\n        out.index = i;\n        out.edge = 2;\n        return;\n      }\n\n      if (faces[i + f_x3] === x1 && faces[i + f_y3] === y1 && faces[i + f_x0] === x0 && faces[i + f_y0] === y0) {\n        out.index = i;\n        out.edge = 3;\n        return;\n      }\n    }\n  }\n\n  out.index = -1;\n}\n\nvar out = {\n  index: -1,\n  edge: 0\n};\n\nfunction getEdgeStack(config, faces) {\n  var length = config.numFaces * 3;\n  var stack = new Int32Array(length);\n  var pos = 0;\n\n  for (var i = 0; i < config.firstPassLen; i += f_size) {\n    var outmostEdge = faces[i + f_outmostEdge];\n    var targetIsOutmostFace = outmostEdge >= 0; // we can't remove any of the outmost edges around the big hexagon (and we avoid having an edge triange as\n    // first merged triangle to simplify edge removal\n\n    if (!targetIsOutmostFace) {\n      var scaled = i << 2;\n      stack[pos++] = scaled;\n      stack[pos++] = scaled + 1;\n      stack[pos++] = scaled + 2;\n    }\n  } // fisher-yates shuffle the stack\n\n\n  for (var _i = 0; _i < pos - 2; _i++) {\n    var j = _i + (Math.random() * pos - _i - 1 | 0);\n\n    var tmp = stack[_i];\n    stack[_i] = stack[j];\n    stack[j] = tmp;\n  }\n\n  return stack.slice(0, pos);\n}\n\nfunction removeRandomEdges(config, faces) {\n  var count = config.firstPassNumEdges * config.removeEdges / 100 | 0; //console.log(\"remove attempts\", count);\n\n  var stack = getEdgeStack(config, faces);\n\n  if (config.debug) {\n    console.log(\"Shuffled stack\", _toConsumableArray(stack.slice()));\n  }\n\n  var stackPos = 0;\n\n  var eraseEdgesOfFaceInStack = function eraseEdgesOfFaceInStack(index) {\n    for (var i = stackPos; i < stack.length; i++) {\n      if (stack[i] >>> 2 === index) {\n        stack[i] = -1;\n      }\n    }\n  };\n\n  var success = 0; // function printEdge(faces, otherIndex, outMostEdge)\n  // {\n  //     const count = faces[otherIndex + f_count];\n  //     const x0 = faces[otherIndex + outMostEdge * 2]\n  //     const y0 = faces[otherIndex + outMostEdge * 2 + 1]\n  //     const x1 = outMostEdge === count -1 ? faces[otherIndex] : faces[otherIndex + (outMostEdge + 1) * 2]\n  //     const y1 = outMostEdge === count -1 ? faces[otherIndex + 1] : faces[otherIndex + (outMostEdge + 1) * 2 + 1]\n  //\n  //\n  //     return x0 + \",\" + y0 + \",\" + x1 + \",\" + y1;\n  // }\n\n  for (var i = 0; i < count; i++) {\n    var code = void 0;\n\n    do {\n      if (stackPos === stack.length) {\n        if (config.debug) {\n          config.debug && console.log(\"Ran out of removal candidates after successfully removing\", success, \"out of\", count);\n        } // no more valid removals\n\n\n        return;\n      }\n\n      code = stack[stackPos++];\n    } while (code === -1);\n\n    var index = code >> 2;\n    var edge = code & 3;\n    var x0 = faces[index + edge * 2];\n    var y0 = faces[index + edge * 2 + 1];\n    var x1 = edge === 2 ? faces[index + f_x0] : faces[index + (edge + 1) * 2];\n    var y1 = edge === 2 ? faces[index + f_y0] : faces[index + (edge + 1) * 2 + 1];\n    findOtherEdge(faces, x0, y0, x1, y1, index, out);\n\n    if (out.index >= 0 && faces[out.index + f_count] === 3) {\n      var otherIndex = out.index,\n          otherEdge = out.edge;\n      var x2 = edge === 0 ? faces[index + f_x2] : faces[index + (edge - 1) * 2];\n      var y2 = edge === 0 ? faces[index + f_y2] : faces[index + (edge - 1) * 2 + 1]; // check if we're merging with an outmost face\n\n      var outMostEdge = faces[otherIndex + 9];\n      var otherIsOutmostTri = outMostEdge >= 0; //const before = printEdge(faces, otherIndex, outMostEdge)\n      // if (otherIsOutmostTri)\n      // {\n      //     console.log(\"OUTMOST edge before split\", printEdge(faces, otherIndex, outMostEdge),\"EDGE CASE\", otherEdge, \"outMostEdge\", outMostEdge)\n      //     console.log(\"face before\", faces.slice(otherIndex, otherIndex + f_size))\n      // }\n\n      faces[otherIndex + 8] = 4;\n\n      switch (otherEdge) {\n        case 2:\n          faces[otherIndex + f_x3] = x2;\n          faces[otherIndex + f_y3] = y2;\n          break;\n\n        case 1:\n          faces[otherIndex + f_x3] = faces[otherIndex + f_x2];\n          faces[otherIndex + f_y3] = faces[otherIndex + f_y2];\n          faces[otherIndex + f_x2] = x2;\n          faces[otherIndex + f_y2] = y2;\n          break;\n\n        case 0:\n          faces[otherIndex + f_x3] = faces[otherIndex + f_x2];\n          faces[otherIndex + f_y3] = faces[otherIndex + f_y2];\n          faces[otherIndex + f_x2] = faces[otherIndex + f_x1];\n          faces[otherIndex + f_y2] = faces[otherIndex + f_y1];\n          faces[otherIndex + f_x1] = x2;\n          faces[otherIndex + f_y1] = y2;\n\n          if (otherIsOutmostTri) {\n            faces[otherIndex + f_outmostEdge] = 2;\n          }\n\n          break;\n      }\n\n      eraseEdgesOfFaceInStack(otherIndex); // remove our face\n\n      faces[index + f_count] = 0;\n      success++;\n    }\n\n    eraseEdgesOfFaceInStack(index);\n  }\n\n  config.debug && console.log(\"Successfully removed\", success, \"out of\", count);\n  return success;\n}\n\nfunction calculateNumNodes(config, faces) {\n  var tris = 0;\n  var quads = 0;\n\n  for (var i = 0; i < config.firstPassLen; i += f_size) {\n    var count = faces[i + f_count];\n\n    if (count === 3) {\n      tris++;\n    } else if (count === 4) {\n      quads++;\n    }\n  } //console.log({quads,tris})\n  // we divide each quad in 9 nodes and each tri into 7 nodes\n\n\n  return quads * 9 + tris * 7;\n}\n\nfunction connectTiles(config, tiles) {\n  var length = tiles.length;\n\n  for (var i = 0; i < length; i += t_size) {\n    var numConnections = 0;\n\n    for (var j = 0; j < 4; j++) {\n      var n0 = tiles[i + t_n0 + j];\n      var n1 = j === 3 ? tiles[i + t_n0] : tiles[i + t_n0 + j + 1];\n      var otherIndex = -1;\n\n      for (var k = 0; k < tiles.length; k += t_size) {\n        if (k === i) {\n          continue;\n        }\n\n        var otherNode0 = tiles[k + t_n0];\n        var otherNode1 = tiles[k + t_n1];\n        var otherNode2 = tiles[k + t_n2];\n        var otherNode3 = tiles[k + t_n3]; // tile edges are all defined in clockwise order, the opposite edge must necessarily walk the two nodes in\n        // the opposite direction\n\n        if (otherNode1 === n0 && otherNode0 === n1 || otherNode2 === n0 && otherNode1 === n1 || otherNode3 === n0 && otherNode2 === n1 || otherNode0 === n0 && otherNode3 === n1) {\n          otherIndex = k;\n          numConnections++;\n          break;\n        }\n      }\n\n      tiles[i + t_tile0 + j] = otherIndex;\n    }\n\n    tiles[i + t_isEdge] = numConnections === 4 ? 0 : 1;\n  }\n\n  config.debug && console.log(\"TILE GRAPH\", tiles);\n}\n\nfunction subdivide(config, faces) {\n  var firstPassLen = config.firstPassLen;\n  var numNodes = calculateNumNodes(config, faces);\n  var nodes = new Float64Array(numNodes * g_size);\n  var tiles = new Int32Array((numNodes / 2 | 0) * t_size);\n  var pos = 0;\n  var tilePos = 0;\n\n  var insertNode = function insertNode(x0, y0, isEdge) {\n    x0 |= 0;\n    y0 |= 0;\n\n    for (var i = 0; i < pos; i += g_size) {\n      if (Math.abs(nodes[i] - x0) < 2 && Math.abs(nodes[i + 1] - y0) < 2) {\n        // if we discover an odd face vertex touching the outmost edge, we will\n        // not register that because the odd tris are not marked as having an outmost edge, because they don't, they\n        // only have one vertices on the edge at most\n        // Later we might however return to that node within an outmost edge and we have to make sure that\n        // we take over the isEdge status from such a node\n        if (isEdge && !nodes[i + 2]) {\n          nodes[i + 2] = 1;\n        }\n\n        return i;\n      }\n    }\n\n    var index = pos;\n    nodes[pos + g_x] = x0;\n    nodes[pos + g_y] = y0;\n    nodes[pos + g_isEdge] = isEdge ? 1 : 0;\n    nodes[pos + g_count] = 0;\n    pos += g_size;\n    return index;\n  };\n\n  var addTile = function addTile(n0, n1, n2, n3) {\n    //console.log(\"addTile\", n0, n1, n2, n3, tilePos)\n    tiles[tilePos + t_n0] = n0;\n    tiles[tilePos + t_n1] = n1;\n    tiles[tilePos + t_n2] = n2;\n    tiles[tilePos + t_n3] = n3;\n    tilePos += t_size;\n  };\n\n  var insertEdge = function insertEdge(n0, n1) {\n    var count = nodes[n0 + 3];\n    var found = false;\n\n    for (var i = 0; i < count; i++) {\n      var other = nodes[n0 + 4 + i];\n\n      if (other === n1) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      if (count >= 10) {\n        throw new Error(\"At most 10 edges per node\");\n      }\n\n      nodes[n0 + 4 + count++] = n1;\n      nodes[n0 + 3] = count;\n    }\n  };\n\n  var connect = function connect(n0, n1) {\n    insertEdge(n0, n1);\n    insertEdge(n1, n0);\n  };\n\n  for (var i = 0; i < firstPassLen; i += f_size) {\n    var count = faces[i + f_count];\n\n    if (count === 0) {\n      continue;\n    }\n\n    var x0 = faces[i + f_x0];\n    var y0 = faces[i + f_y0];\n    var x1 = faces[i + f_x1];\n    var y1 = faces[i + f_y1];\n    var x2 = faces[i + f_x2];\n    var y2 = faces[i + f_y2];\n    var outmostEdge = faces[i + f_outmostEdge];\n    var firstEdgeIsOutmost = outmostEdge === 1;\n    var secondEdgeIsOutmost = outmostEdge === 2;\n\n    if (count === 3) {\n      var m0x = (x0 + x1) / 2;\n      var m0y = (y0 + y1) / 2;\n      var m1x = (x1 + x2) / 2;\n      var m1y = (y1 + y2) / 2;\n      var m2x = (x2 + x0) / 2;\n      var m2y = (y2 + y0) / 2;\n      var cx = (x0 + x1 + x2) / 3;\n      var cy = (y0 + y1 + y2) / 3;\n      var n0 = insertNode(x0, y0);\n      var n1 = insertNode(m0x, m0y);\n      var n2 = insertNode(x1, y1, firstEdgeIsOutmost);\n      var n3 = insertNode(m1x, m1y, firstEdgeIsOutmost);\n      var n4 = insertNode(x2, y2, firstEdgeIsOutmost);\n      var n5 = insertNode(m2x, m2y);\n      var n6 = insertNode(cx, cy);\n      connect(n0, n1);\n      connect(n1, n6);\n      connect(n6, n5);\n      connect(n5, n0);\n      connect(n1, n2);\n      connect(n2, n3);\n      connect(n3, n6);\n      connect(n6, n1);\n      connect(n5, n6);\n      connect(n6, n3);\n      connect(n3, n4);\n      connect(n4, n5);\n      addTile(n0, n1, n6, n5);\n      addTile(n1, n2, n3, n6);\n      addTile(n5, n6, n3, n4);\n    } else {\n      var x3 = faces[i + f_x3];\n      var y3 = faces[i + f_y3];\n\n      var _m0x = (x0 + x1) / 2;\n\n      var _m0y = (y0 + y1) / 2;\n\n      var _m1x = (x1 + x2) / 2;\n\n      var _m1y = (y1 + y2) / 2;\n\n      var _m2x = (x2 + x3) / 2;\n\n      var _m2y = (y2 + y3) / 2;\n\n      var m3x = (x3 + x0) / 2;\n      var m3y = (y3 + y0) / 2;\n\n      var _cx = (x0 + x1 + x2 + x3) / 4;\n\n      var _cy = (y0 + y1 + y2 + y3) / 4;\n\n      var _n = insertNode(x0, y0);\n\n      var _n2 = insertNode(_m0x, _m0y);\n\n      var _n3 = insertNode(x1, y1, firstEdgeIsOutmost);\n\n      var _n4 = insertNode(_m1x, _m1y, firstEdgeIsOutmost);\n\n      var _n5 = insertNode(x2, y2, firstEdgeIsOutmost || secondEdgeIsOutmost);\n\n      var _n6 = insertNode(_m2x, _m2y, secondEdgeIsOutmost);\n\n      var _n7 = insertNode(x3, y3, secondEdgeIsOutmost);\n\n      var n7 = insertNode(m3x, m3y);\n      var n8 = insertNode(_cx, _cy);\n      connect(_n, _n2);\n      connect(_n2, _n3);\n      connect(_n3, _n4);\n      connect(_n4, _n5);\n      connect(_n5, _n6);\n      connect(_n6, _n7);\n      connect(_n7, n7);\n      connect(n7, _n);\n      connect(n8, _n4);\n      connect(n8, _n6);\n      connect(n8, n7);\n      connect(n8, _n2);\n      addTile(_n, _n2, n8, n7);\n      addTile(_n2, _n3, _n4, n8);\n      addTile(n8, _n4, _n5, _n6);\n      addTile(n7, n8, _n6, _n7);\n    }\n  } //const fillRate = (pos / g_size) / numNodes;\n  //console.log(\"SUBDIVIDED: limit = \", numNodes, \", fill rate = \", fillRate);\n\n\n  console.log(\"TILES: buffer = \", tiles.length, \", used = \" + tilePos);\n  var newTiles = tiles.slice(0, tilePos);\n  connectTiles(config, newTiles);\n  return [nodes.slice(0, pos), newTiles];\n}\n\nfunction relaxWeighted(config, graph) {\n  var maxIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var length = graph.length;\n\n  for (var i = 0; i < maxIterations; i++) {\n    var tension = 0;\n\n    for (var j = 0; j < length; j += g_size) {\n      if (!graph[j + g_isEdge]) {\n        var x0 = graph[j + g_x];\n        var y0 = graph[j + g_y];\n        var edgeCount = graph[j + g_count];\n        var centerX = 0;\n        var centerY = 0;\n        var sumWeight = 0;\n\n        for (var k = 0; k < edgeCount; k++) {\n          var other = graph[j + 4 + k];\n          var _x = graph[other];\n          var _y = graph[other + 1];\n          var weight = config.weightFunction(x0, y0, _x, _y);\n          centerX += _x * weight;\n          centerY += _y * weight;\n          sumWeight += weight;\n        }\n\n        var x1 = centerX / sumWeight;\n        var y1 = centerY / sumWeight;\n        var dx = x1 - x0;\n        var dy = y1 - y0;\n        graph[j + g_x] = x1;\n        graph[j + g_y] = y1;\n        tension += dx * dx + dy * dy;\n      }\n    }\n\n    if (tension < config.minTension) {\n      config.debug && console.log(\"Reached minimal tension\", config.minTension, \"after\", config.relaxCount, \"iterations\");\n      return true;\n    }\n\n    config.relaxCount++;\n  }\n\n  if (!config.animatedEasing) {\n    config.debug && console.log(\"Stopping after max iterations = \" + config.maxIterations);\n  }\n\n  return false;\n}\n/**\n * A hexagon filled with quads forming organic shapes.\n */\n\n\nvar OrganicQuads = function OrganicQuads(cfg) {\n  var _this = this;\n\n  _classCallCheck(this, OrganicQuads);\n\n  this.render = function (ctx) {\n    var config = _this.config,\n        graph = _this.graph,\n        faces = _this.faces;\n    ctx.save();\n    var hw = config.width / 2;\n    var hh = config.height / 2;\n    ctx.translate(hw, hh);\n    var length = graph.length;\n    ctx.fillStyle = \"#000\";\n    ctx.fillRect(-hw, -hh, config.width, config.height);\n\n    if (config.renderFirstPassEdges) {\n      // draw original quads and tris\n      ctx.strokeStyle = \"#f00\";\n      ctx.lineWidth = 1;\n      var outerCount = 0;\n\n      for (var pos = 0; pos < config.firstPassLen; pos += f_size) {\n        var count = faces[pos + f_count];\n\n        if (count >= 3) {\n          ctx.beginPath();\n          ctx.moveTo(faces[pos + f_x0], faces[pos + f_y0]);\n\n          for (var i = 1; i < count; i++) {\n            ctx.lineTo(faces[pos + i * 2], faces[pos + i * 2 + 1]);\n          }\n\n          ctx.closePath();\n          ctx.stroke();\n          var outmostEdge = faces[pos + f_outmostEdge];\n\n          if (outmostEdge >= 0) {\n            ctx.strokeStyle = \"#fe0\";\n            ctx.beginPath();\n            ctx.moveTo(faces[pos + outmostEdge * 2], faces[pos + outmostEdge * 2 + 1]);\n\n            if (outmostEdge === count - 1) {\n              ctx.lineTo(faces[pos + f_x0], faces[pos + f_y0]);\n            } else {\n              ctx.lineTo(faces[pos + (outmostEdge + 1) * 2], faces[pos + (outmostEdge + 1) * 2 + 1]);\n            }\n\n            ctx.stroke();\n            ctx.strokeStyle = \"#f00\";\n            outerCount++;\n          }\n        }\n      } //    console.log(\"Number of outer edges\", outerCount)\n      //console.log(\"DRAW EDGES\")\n\n    } // ctx.strokeStyle = \"#fff\";\n    // ctx.lineWidth = 1;\n    //\n    //\n    // function drawEdge(x0, y0, node)\n    // {\n    //     const x1 = graph[node + g_x];\n    //     const y1 = graph[node + g_y];\n    //\n    //     ctx.beginPath();\n    //     ctx.moveTo(x0, y0);\n    //     ctx.lineTo(x1, y1);\n    //     ctx.stroke();\n    // }\n    //\n    //\n    // for (let i = 0; i < length; i += g_size)\n    // {\n    //     const x0 = graph[i + g_x];\n    //     const y0 = graph[i + g_y];\n    //     const edgeCount = graph[i + g_count];\n    //\n    //     for (let j = 0; j < edgeCount; j++)\n    //     {\n    //         drawEdge(x0, y0, graph[i + g_edge0 + j])\n    //     }\n    // }\n    //ctx.fillStyle = \"#f0f\";\n    //\n    // for (let i = 0; i < length; i += g_size)\n    // {\n    //     const x0 = graph[i + g_x];\n    //     const y0 = graph[i + g_y];\n    //     const isEdge = graph[i + g_isEdge];\n    //\n    //     if (isEdge)\n    //     {\n    //         ctx.fillRect(x0 - 4,  y0 - 4, 8, 8)\n    //     }\n    // }\n    // ctx.strokeStyle = \"#f00\";\n    // ctx.lineWidth = 4;\n    //\n    // for (let pos = 0; pos < config.firstPassLen; pos += f_size)\n    // {\n    //     const count = faces[pos + f_count];\n    //     const outmostEdge = faces[pos + f_outmostEdge];\n    //\n    //\n    //     const last = count - 1;\n    //     for (let i=0; i < count; i++)\n    //     {\n    //         if (i === outmostEdge)\n    //         {\n    //             ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n    //         }\n    //         else\n    //         {\n    //             ctx.strokeStyle = \"rgba(0,255,0,0.5)\";\n    //         }\n    //\n    //         ctx.beginPath();\n    //         ctx.moveTo(faces[pos + i * 2], faces[pos + i * 2 + 1]);\n    //         ctx.lineTo(\n    //             i === last ? faces[pos + f_x0 ] : faces[pos + (i+1) * 2],\n    //             i === last ? faces[pos + f_y0 ] : faces[pos + (i+1) * 2 + 1]\n    //         );\n    //         ctx.stroke();\n    //     }\n    // }\n\n\n    ctx.restore();\n\n    if (config.animating) {\n      if (relaxWeighted(config, graph)) {\n        config.animating = false;\n      } //            raf(redrawGraph)\n\n    }\n  };\n\n  var _config = _objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg);\n\n  updateConfig(_config);\n  this.config = _config;\n\n  var _faces = createHexagonTriangles(_config);\n\n  if (_config.renderFirstPassEdges) {\n    this.faces = _config.renderFirstPassEdges !== \"merged\" ? _faces.slice() : _faces;\n  }\n\n  var start = _config.debug && (0, _performanceNow.default)();\n  removeRandomEdges(_config, _faces);\n  _config.debug && console.log(\"Edge removal in \", (0, _performanceNow.default)() - start, \"ms\");\n\n  var _subdivide = subdivide(_config, _faces),\n      _subdivide2 = _slicedToArray(_subdivide, 2),\n      _graph = _subdivide2[0],\n      tiles = _subdivide2[1];\n\n  this.tiles = tiles;\n\n  if (!_config.animating) {\n    relaxWeighted(_config, _graph, _config.maxIterations);\n  } //console.log(\"GRAPH f_size\", graph.length / g_size, graph);\n\n\n  this.graph = _graph;\n};\n\nvar _default = OrganicQuads;\nexports.default = _default;\n\n//# sourceURL=webpack://Demo/../organic-quads/lib/index.js?");

/***/ }),

/***/ "../organic-quads/lib/vector.js":
/*!**************************************!*\
  !*** ../organic-quads/lib/vector.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar sqrt = Math.sqrt;\n\nvar Vector = /*#__PURE__*/function () {\n  function Vector(x, y) {\n    _classCallCheck(this, Vector);\n\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Returns a copy of this vector.\n   *\n   * @returns {Vector} copy\n   */\n\n\n  _createClass(Vector, [{\n    key: \"copy\",\n    value: function copy() {\n      return new Vector(this.x, this.y);\n    }\n    /**\n     * Adds to this vector\n     *\n     * @param x     {number|Vector} x coordinate or a vector\n     * @param y     {number?} y coordinate, ignored if x is a vector\n     * @returns {Vector} this vector\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(x, y) {\n      if (typeof x === \"number\") {\n        this.x += x;\n        this.y += y;\n      } else {\n        this.x += x.x;\n        this.y += x.y;\n      }\n\n      return this;\n    }\n    /**\n     * Subtracts from this vector\n     *\n     * @param x     {number|Vector} x coordinate or a vector\n     * @param y     {number?} y coordinate, ignored if x is a vector\n     * @returns {Vector} this vector\n     */\n\n  }, {\n    key: \"subtract\",\n    value: function subtract(x, y) {\n      if (typeof x === \"number\") {\n        this.x -= x;\n        this.y -= y;\n      } else {\n        this.x -= x.x;\n        this.y -= x.y;\n      }\n\n      return this;\n    }\n    /**\n     * Scales the vector by a planar number.\n     *\n     * @param n     scale\n     * @returns {Vector} this vector, scaled\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(n) {\n      this.x *= n;\n      this.y *= n;\n      return this;\n    }\n    /**\n     * Length of this vector\n     *\n     * @returns {number}    length\n     */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      var x = this.x,\n          y = this.y;\n      return sqrt(x * x + y * y);\n    }\n    /**\n     * Scales the vector to normal length or a specified length\n     *\n     * @param targetLength      {number?} target length of the vector (default is 1, the normal vector length)\n     *\n     * @returns {Vector}\n     */\n\n  }, {\n    key: \"norm\",\n    value: function norm() {\n      var targetLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      return this.scale(targetLength / this.length());\n    }\n    /**\n     * Rotate vector 90 degrees clockwise.\n     *\n     * @returns {Vector}\n     */\n\n  }, {\n    key: \"rotateClockwise\",\n    value: function rotateClockwise() {\n      var x = this.x,\n          y = this.y; //noinspection JSSuspiciousNameCombination\n\n      this.x = y;\n      this.y = -x;\n      return this;\n    }\n    /**\n     * Rotate vector 90 degrees counter clockwise.\n     *\n     * @returns {Vector}\n     */\n\n  }, {\n    key: \"rotateCounterClockwise\",\n    value: function rotateCounterClockwise() {\n      var x = this.x,\n          y = this.y;\n      this.x = -y; //noinspection JSSuspiciousNameCombination\n\n      this.y = x;\n      return this;\n    }\n    /**\n     * Sets the coordinates of this vector\n     *\n     * @param x     {number|Vector} x coordinate or a vector\n     * @param y     {number?} y coordinate, ignored if x is a vector\n     * @returns {Vector} this vector\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(x, y) {\n      if (typeof x === \"number\") {\n        this.x = x;\n        this.y = y;\n      } else {\n        this.x = x.x;\n        this.y = x.y;\n      }\n    }\n  }]);\n\n  return Vector;\n}();\n\nvar _default = Vector;\nexports.default = _default;\n\n//# sourceURL=webpack://Demo/../organic-quads/lib/vector.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! raf */ \"./node_modules/raf/index.js\");\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(raf__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/simplex-noise.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(simplex_noise__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fforw/organic-quads */ \"../organic-quads/lib/index.js\");\n/* harmony import */ var _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _loadScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadScene */ \"./src/loadScene.js\");\n/* harmony import */ var three_examples_jsm_objects_Water_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/objects/Water.js */ \"./node_modules/three/examples/jsm/objects/Water.js\");\n/* harmony import */ var three_examples_jsm_objects_Sky_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three/examples/jsm/objects/Sky.js */ \"./node_modules/three/examples/jsm/objects/Sky.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n/* harmony import */ var _loadTexture__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./loadTexture */ \"./src/loadTexture.js\");\nvar _GROUND_COLORS;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n // noinspection ES6UnusedImports\n\n\n\n\n\n\n\n\n\nvar EFFECTS = false;\nvar MAX_HEIGHT = 300;\nvar QUARTER_HEIGHT = MAX_HEIGHT / 4;\nvar NOISE_SCALE = 0.003;\nvar CLIFF_THRESHOLD = 20;\nvar RANDOM_FACTOR = 0.2;\nvar WATER = 0;\nvar SAND = 1;\nvar GRASS = 2;\nvar DIRT = 3;\nvar FOREST = 4;\nvar STONE = 5;\nvar GROUND_COLORS = (_GROUND_COLORS = {}, _defineProperty(_GROUND_COLORS, WATER, [0, 0.4, 0.8]), _defineProperty(_GROUND_COLORS, SAND, [0.8, 0.8, 0]), _defineProperty(_GROUND_COLORS, GRASS, [0, 0.5, 0]), _defineProperty(_GROUND_COLORS, DIRT, [0.5, 0.3, 0.1]), _defineProperty(_GROUND_COLORS, FOREST, [0.2, 0.4, 0.3]), _defineProperty(_GROUND_COLORS, STONE, [0.5, 0.5, 0.5]), _GROUND_COLORS);\nvar container, stats;\nvar camera, scene, renderer, light;\nvar controls, water, sphere;\nvar centroids;\nvar heightMap;\n\nfunction updateCentroids() {\n  var _organicQuads = organicQuads,\n      graph = _organicQuads.graph,\n      tiles = _organicQuads.tiles,\n      config = _organicQuads.config;\n  var length = tiles.length;\n  var cPos = 0;\n\n  for (var i = 0; i < length; i += _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"]) {\n    var n0 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n0\"]];\n    var n1 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n1\"]];\n    var n2 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n2\"]];\n    var n3 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n3\"]];\n    var cx = (graph[n0 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]] + graph[n1 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]] + graph[n2 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]] + graph[n3 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]]) / 4;\n    var cy = (graph[n0 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]] + graph[n1 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]] + graph[n2 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]] + graph[n3 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]]) / 4;\n    centroids[cPos++] = cx;\n    centroids[cPos++] = cy;\n  }\n}\n\nvar organicQuads, envMap;\nvar FLAT_DISTANCE = 300;\nvar FACTOR = Math.PI / 2 / FLAT_DISTANCE;\n\nfunction heightFn(x0, z0) {\n  var distance = Math.sqrt(x0 * x0 + z0 * z0);\n  var heightLimit = distance < FLAT_DISTANCE ? Math.cos(distance * FACTOR) : 0;\n  return (QUARTER_HEIGHT + (noise.noise2D(x0 * NOISE_SCALE, z0 * NOISE_SCALE) - Math.random() * RANDOM_FACTOR) * QUARTER_HEIGHT) * heightLimit;\n}\n\nvar tmpHeight = new Float64Array(5);\n\nfunction cutCliffs() {\n  var _organicQuads2 = organicQuads,\n      graph = _organicQuads2.graph,\n      tiles = _organicQuads2.tiles;\n  var heightIndexFactor = h_size / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_size\"];\n  var centroidsFactor = 2 / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"];\n\n  for (var i = 0; i < length; i += _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"]) {\n    // node indizes for our quad\n    var n0 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n0\"]];\n    var n1 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n1\"]];\n    var n2 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n2\"]];\n    var n3 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n3\"]]; // find indizes for connected centroid (values might be -1 if on the edge or already cut)\n\n    var centroid = i * centroidsFactor;\n    var centroid0 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile0\"]] * centroidsFactor;\n    var centroid1 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile1\"]] * centroidsFactor;\n    var centroid2 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile2\"]] * centroidsFactor;\n    var centroid3 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile3\"]] * centroidsFactor;\n    tmpHeight[0] = heightFn(centroids[centroid], centroids[centroid + 1]);\n    tmpHeight[1] = centroid0 >= 0 ? heightFn(centroids[centroid0], centroids[centroid0 + 1]) : -1;\n    tmpHeight[2] = centroid1 >= 0 ? heightFn(centroids[centroid1], centroids[centroid1 + 1]) : -1;\n    tmpHeight[3] = centroid2 >= 0 ? heightFn(centroids[centroid2], centroids[centroid2 + 1]) : -1;\n    tmpHeight[4] = centroid3 >= 0 ? heightFn(centroids[centroid3], centroids[centroid3 + 1]) : -1;\n    var cutMask = 0;\n\n    if (centroid0 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[1]) > CLIFF_THRESHOLD) {\n      cutMask |= 3;\n    }\n\n    if (centroid1 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[2]) > CLIFF_THRESHOLD) {\n      cutMask |= 6;\n    }\n\n    if (centroid2 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[3]) > CLIFF_THRESHOLD) {\n      cutMask |= 12;\n    }\n\n    if (centroid3 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[4]) > CLIFF_THRESHOLD) {\n      cutMask |= 9;\n    }\n\n    if (cutMask !== 0) {\n      var height = tmpHeight[0]; // if all edges are cut, keep using the centroid heightmap value,\n      // otherwise recalculate the height as average of the uncut points\n\n      if (cutMask !== 15) {\n        height = 0;\n        var count = 0;\n\n        for (var j = 0; j < 4; j++) {\n          if ((cutMask & 1 << j) === 0) {\n            height += tmpHeight[j + 1];\n            count++;\n          }\n        }\n\n        height /= count;\n      }\n\n      for (var _j = 0; _j < 4; _j++) {\n        if (cutMask & 1 << _j) {\n          var _heightMapIndex = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n0\"] + _j] * heightIndexFactor;\n\n          console.log(\"Cut #\" + _heightMapIndex / h_size, height);\n          heightMap[_heightMapIndex + h_cutZ] = height;\n          heightMap[_heightMapIndex + h_ground] = STONE;\n          var other = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile0\"] + _j]; // cut our connection to the other tile\n\n          tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile0\"] + _j] = -1; // and remove us from the other tile\n\n          for (var k = 0; k < 4; k++) {\n            if (tiles[other + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile0\"] + k] === i) {\n              tiles[other + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_tile0\"] + k] = -1;\n            }\n          }\n        } else {\n          heightMap[heightMapIndex + h_cutZ] = -1;\n        }\n      }\n    }\n  }\n}\n\nvar h_height = 0;\nvar h_ground = 1;\nvar h_cutZ = 2;\nvar h_size = 3;\n\nfunction createScene() {\n  organicQuads = new _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5___default.a({\n    numberOfRings: 6,\n    width: 1000,\n    height: 1000,\n    graphUserData: 1 // weightFunction: (x0,y0,x1,y1) => {\n    //\n    //     const dx = x1 - x0;\n    //     const dy = y1 - y0;\n    //     const dz = heightFn(x0,y0) - heightFn(x1,y1);\n    //\n    //     return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    //\n    // }\n\n  });\n  var _organicQuads3 = organicQuads,\n      graph = _organicQuads3.graph,\n      config = _organicQuads3.config;\n  var length = graph.length;\n  heightMap = new Float64Array(length / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_size\"] * h_size);\n  var pos = 0;\n\n  for (var i = 0; i < length; i += _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_size\"]) {\n    heightMap[pos + h_height] = heightFn(graph[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]], graph[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]]);\n    heightMap[pos + h_ground] = GRASS;\n    pos += h_size;\n  }\n\n  centroids = new Float64Array(organicQuads.tiles.length / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"] * 2);\n  updateCentroids();\n  cutCliffs();\n}\n\nvar noise = new simplex_noise__WEBPACK_IMPORTED_MODULE_2___default.a();\n\nfunction checkNaN(value, msg) {\n  if (isNaN(value)) {\n    debugger;\n    throw new Error(msg + \": value is NaN\");\n  }\n}\n\nfunction addHeightMap() {\n  var geometry = new three__WEBPACK_IMPORTED_MODULE_4__[\"BufferGeometry\"]();\n  geometry.name = \"Landscape-Debug\";\n  var vertices = [];\n  var normals = [];\n  var colors = [];\n  var size = 20;\n  var segments = 10;\n  var halfSize = size / 2;\n  var segmentSize = size / segments; // generate vertices, normals and color data for a simple grid geometry\n\n  var _organicQuads4 = organicQuads,\n      graph = _organicQuads4.graph,\n      tiles = _organicQuads4.tiles,\n      config = _organicQuads4.config;\n  var length = tiles.length;\n  console.log(\"Height map for \", length / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"], \" tiles\");\n  var heightIndexFactor = h_size / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_size\"];\n  var centroidsFactor = 2 / _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"];\n  var UNDEFINED_COLOR = [1, 0, 1];\n\n  var getColor = function getColor(hIdx) {\n    return GROUND_COLORS[heightMap[hIdx + h_ground]] || UNDEFINED_COLOR;\n  };\n\n  for (var i = 0; i < length; i += _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_size\"]) {\n    // node indizes for our quad\n    var n0 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n0\"]];\n    var n1 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n1\"]];\n    var n2 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n2\"]];\n    var n3 = tiles[i + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"t_n3\"]]; // equivalent height map indizes\n\n    var heightIndex0 = n0 * heightIndexFactor;\n    var heightIndex1 = n1 * heightIndexFactor;\n    var heightIndex2 = n2 * heightIndexFactor;\n    var heightIndex3 = n3 * heightIndexFactor;\n    var x0 = graph[n0 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]];\n    var y0 = heightMap[heightIndex0 + h_cutZ] === -1 ? heightMap[heightIndex0] : heightMap[heightIndex0 + h_cutZ];\n    var z0 = graph[n0 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]];\n    var x1 = graph[n1 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]];\n    var y1 = heightMap[heightIndex1 + h_cutZ] === -1 ? heightMap[heightIndex1] : heightMap[heightIndex1 + h_cutZ];\n    var z1 = graph[n1 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]];\n    var x2 = graph[n2 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]];\n    var y2 = heightMap[heightIndex2 + h_cutZ] === -1 ? heightMap[heightIndex2] : heightMap[heightIndex2 + h_cutZ];\n    var z2 = graph[n2 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]];\n    var x3 = graph[n3 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_x\"]];\n    var y3 = heightMap[heightIndex3 + h_cutZ] === -1 ? heightMap[heightIndex3] : heightMap[heightIndex3 + h_cutZ];\n    var z3 = graph[n3 + _fforw_organic_quads__WEBPACK_IMPORTED_MODULE_5__[\"g_y\"]];\n    var ax = x0 - x1;\n    var ay = y0 - y1;\n    var az = z0 - z1;\n    var bx = x2 - x1;\n    var by = y2 - y1;\n    var bz = z2 - z1;\n    var cx = x3 - x1;\n    var cy = y3 - y1;\n    var cz = z3 - z1; // normal vector based on points 0, 1 and 2\n\n    var n0x = ay * bz - az * by;\n    var n0y = az * bx - ax * bz;\n    var n0z = ax * by - ay * bx; // normal vector based on points 0, 1 and 3\n\n    var n1x = ay * cz - az * cy;\n    var n1y = az * cx - ax * cz;\n    var n1z = ax * cy - ay * cx; // average and renormalize\n\n    var nx = (n0x + n1x) / 2;\n    var ny = (n0y + n1y) / 2;\n    var nz = (n0z + n1z) / 2;\n    var f = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n    nx *= f;\n    ny *= f;\n    nz *= f;\n    vertices.push(x0, y0, z0);\n    vertices.push(x3, y3, z3);\n    vertices.push(x1, y1, z1);\n    vertices.push(x1, y1, z1);\n    vertices.push(x3, y3, z3);\n    vertices.push(x2, y2, z2);\n    normals.push(nx, ny, nz);\n    normals.push(nx, ny, nz);\n    normals.push(nx, ny, nz);\n    normals.push(nx, ny, nz);\n    normals.push(nx, ny, nz);\n    normals.push(nx, ny, nz); // const cf = 4 / MAX_HEIGHT;\n    //\n    // colors.push( y3 * cf,1 - y3 * cf, 0);\n    // colors.push( y1 * cf,1 - y1 * cf, 0);\n    // colors.push( y1 * cf,1 - y1 * cf, 0);\n    // colors.push( y3 * cf,1 - y3 * cf, 0);\n    // colors.push( y2 * cf,1 - y2 * cf, 0);\n\n    var col0 = getColor(heightIndex0);\n    var col1 = getColor(heightIndex1);\n    var col2 = getColor(heightIndex2);\n    var col3 = getColor(heightIndex3);\n    colors.push(col0[0], col0[1], col0[2]);\n    colors.push(col3[0], col3[1], col3[2]);\n    colors.push(col1[0], col1[1], col1[2]);\n    colors.push(col1[0], col1[1], col1[2]);\n    colors.push(col3[0], col3[1], col3[2]);\n    colors.push(col2[0], col2[1], col2[2]);\n  } //console.log(\"MAX DELTA\", max);\n  //\n\n\n  console.log({\n    vertices: vertices,\n    normals: normals,\n    colors: colors\n  });\n  geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_4__[\"Float32BufferAttribute\"](vertices, 3));\n  geometry.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_4__[\"Float32BufferAttribute\"](normals, 3));\n  geometry.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_4__[\"Float32BufferAttribute\"](colors, 3));\n  var material = new three__WEBPACK_IMPORTED_MODULE_4__[\"MeshStandardMaterial\"]({\n    vertexColors: true,\n    side: three__WEBPACK_IMPORTED_MODULE_4__[\"FrontSide\"],\n    roughness: 0.5\n  }); // material.onBeforeCompile = shader => {\n  //\n  //     const {vertexShader,fragmentShader,uniforms} = shader;\n  //\n  //     console.log(\"--- VERT:\\n\", vertexShader);\n  //     console.log(\"--- FRAG:\\n\", fragmentShader);\n  //     console.log({uniforms})\n  // };\n\n  var mesh = new three__WEBPACK_IMPORTED_MODULE_4__[\"Mesh\"](geometry, material);\n  mesh.position.set(0, 0.1, 0); // var wireframe = new WireframeGeometry( geometry );\n  //\n  // var line = new LineSegments( wireframe );\n  // line.material.depthTest = false;\n  // line.material.opacity = 0.25;\n  // line.material.transparent = true;\n  //\n  //\n  // scene.add( line );\n\n  scene.add(mesh);\n}\n\nfunction init() {\n  createScene();\n  container = document.getElementById(\"container\"); //\n\n  renderer = new three__WEBPACK_IMPORTED_MODULE_4__[\"WebGLRenderer\"]();\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  container.appendChild(renderer.domElement); //\n\n  scene = new three__WEBPACK_IMPORTED_MODULE_4__[\"Scene\"]();\n  camera = new three__WEBPACK_IMPORTED_MODULE_4__[\"PerspectiveCamera\"](55, window.innerWidth / window.innerHeight, 1, 20000);\n  camera.position.set(250, 250, 1000); //\n\n  light = new three__WEBPACK_IMPORTED_MODULE_4__[\"DirectionalLight\"](\"#fff8d5\", 0.8);\n  scene.add(light);\n  var cubeCamera = new three__WEBPACK_IMPORTED_MODULE_4__[\"CubeCamera\"](0.2, 1, 512);\n  cubeCamera.renderTarget.texture.generateMipmaps = true;\n  cubeCamera.renderTarget.texture.minFilter = three__WEBPACK_IMPORTED_MODULE_4__[\"LinearMipmapLinearFilter\"];\n  scene.background = cubeCamera.renderTarget; // Water\n\n  var waterGeometry = new three__WEBPACK_IMPORTED_MODULE_4__[\"PlaneBufferGeometry\"](10000, 10000);\n\n  if (EFFECTS) {\n    water = new three_examples_jsm_objects_Water_js__WEBPACK_IMPORTED_MODULE_7__[\"Water\"](waterGeometry, {\n      textureWidth: 512,\n      textureHeight: 512,\n      waterNormals: waterNormals,\n      alpha: 0.6,\n      sunDirection: light.position.clone().normalize(),\n      sunColor: \"#fff8d5\",\n      waterColor: \"#000e1e\",\n      distortionScale: 2.5,\n      fog: true\n    });\n    water.rotation.x = -Math.PI / 2;\n    scene.add(water);\n  } else {\n    var material = new three__WEBPACK_IMPORTED_MODULE_4__[\"MeshStandardMaterial\"]({\n      side: three__WEBPACK_IMPORTED_MODULE_4__[\"FrontSide\"],\n      color: \"#048\",\n      envMap: cubeCamera.renderTarget.texture,\n      roughness: 0.0\n    });\n    var mesh = new three__WEBPACK_IMPORTED_MODULE_4__[\"Mesh\"](waterGeometry, material);\n    mesh.rotation.x = -Math.PI / 2;\n    scene.add(mesh);\n  }\n\n  var parameters = {\n    distance: 1000,\n    inclination: 0.05,\n    azimuth: 0.25\n  }; // Skybox\n\n  var sky;\n\n  if (EFFECTS) {\n    sky = new three_examples_jsm_objects_Sky_js__WEBPACK_IMPORTED_MODULE_8__[\"Sky\"]();\n    var uniforms = sky.material.uniforms;\n    uniforms[\"turbidity\"].value = 5;\n    uniforms[\"rayleigh\"].value = 1.5;\n    uniforms[\"luminance\"].value = 1;\n    uniforms[\"mieCoefficient\"].value = 0.05;\n    uniforms[\"mieDirectionalG\"].value = 0.9;\n    envMap = cubeCamera.renderTarget.texture;\n    updateSun();\n  } else {\n    envMap = null;\n  }\n\n  function updateSun() {\n    var theta = Math.PI * (parameters.inclination - 0.5);\n    var phi = 2 * Math.PI * (parameters.azimuth - 0.5);\n    light.position.x = parameters.distance * Math.cos(phi);\n    light.position.y = parameters.distance * Math.sin(phi) * Math.sin(theta);\n    light.position.z = parameters.distance * Math.sin(phi) * Math.cos(theta);\n    sky.material.uniforms[\"sunPosition\"].value = light.position.copy(light.position);\n    water && water.material.uniforms[\"sunDirection\"].value.copy(light.position).normalize();\n    cubeCamera.update(renderer, sky);\n  }\n\n  controls = new three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_9__[\"OrbitControls\"](camera, renderer.domElement);\n  controls.maxPolarAngle = Math.PI * 0.45;\n  controls.target.set(0, 0, 0);\n  controls.minDistance = 40.0;\n  controls.maxDistance = 1000.0;\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.02;\n  controls.update(); // stats = new Stats();\n  // container.appendChild( stats.dom );\n  // GUI\n  //const gui = new GUI();\n  // const folder = gui.addFolder( \"Sky\" );\n  // folder.add( parameters, \"inclination\", 0, 0.5, 0.0001 ).onChange( updateSun );\n  // folder.add( parameters, \"azimuth\", 0, 1, 0.0001 ).onChange( updateSun );\n  // folder.open();\n  //\n  // const uniforms = water.material.uniforms;\n  //\n  // const folder = gui.addFolder( \"Water\" );\n  // folder.add( uniforms.distortionScale, \"value\", 0, 8, 0.1 ).name( \"distortionScale\" );\n  // folder.add( uniforms.size, \"value\", 0.1, 10, 0.1 ).name( \"size\" );\n  // folder.add( uniforms.alpha, \"value\", 0.9, 1, .001 ).name( \"alpha\" );\n  // folder.open();\n\n  window.addEventListener(\"resize\", onWindowResize, false); ////////////////\n\n  addHeightMap();\n}\n\nfunction onWindowResize() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n}\n\nfunction mainLoop() {\n  render(); //stats.update();\n\n  controls.update();\n  raf__WEBPACK_IMPORTED_MODULE_1___default()(mainLoop);\n}\n\nfunction render() {\n  var time = performance.now() * 0.001; // sphere.position.y = Math.sin( time ) * 5 + 1;\n  // sphere.rotation.x = time * 0.5;\n  // sphere.rotation.z = time * 0.51;\n\n  if (water) {\n    water.material.uniforms[\"time\"].value += 1.0 / 60.0;\n  }\n\n  renderer.render(scene, camera);\n}\n\nvar waterNormals;\n\nfunction extractMarchingSquares(scene) {\n  var children = scene.children;\n  var map = new Map();\n\n  for (var i = 0; i < children.length; i++) {\n    var kid = children[i];\n\n    if (kid.name.indexOf(\"case-\") === 0) {\n      map.set(kid.name, kid);\n    }\n  }\n\n  return map;\n}\n\nPromise.all([0, //        loadScene(\"assets/tiles.glb\"),\n0, //        loadScene(\"assets/ground.glb\"),\nObject(_loadScene__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"assets/ms.glb\"), Object(_loadScene__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"assets/ms-raised.glb\"), Object(_loadTexture__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(\"assets/waternormals.jpg\")]).then(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 5),\n      tiles = _ref2[0],\n      ground = _ref2[1],\n      marchingSquares = _ref2[2],\n      marchingSquaresRaised = _ref2[3],\n      tWaterNormals = _ref2[4];\n\n  //scene.add( tiles.scene );\n  function dump(obj) {\n    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var type = obj.type;\n\n    if (type === \"Group\") {\n      console.log(level + \"GROUP\", obj.name);\n      var nextLevel = level + \"    \";\n      var children = obj.children;\n\n      for (var i = 0; i < children.length; i++) {\n        dump(children[i], nextLevel);\n      }\n    } else if (type === \"Mesh\") {\n      console.log(level + \"MESH\", obj.name);\n    }\n  }\n\n  console.log({\n    ground: ground\n  }); // const msMap = extractMarchingSquares(marchingSquares.scene);\n  // const msMapRaised = extractMarchingSquares(marchingSquaresRaised.scene);\n  //\n  // console.log({msMap, msMapRaised})\n  // dump(marchingSquares.scene, \"ms-normal: \");\n  // dump(marchingSquaresRaised.scene, \"ms-raised: \");\n\n  console.log(\"GLTF\", tiles); // console.log(\"Scene Objects\", tiles.scene.children.map(kid => kid.name).join(\", \"))\n  //\n  // const obj  = tiles.scene.children.find(\n  //     kid => kid.name === \"tree_default\"\n  // );\n\n  tWaterNormals.wrapS = tWaterNormals.wrapT = three__WEBPACK_IMPORTED_MODULE_4__[\"RepeatWrapping\"];\n  waterNormals = tWaterNormals; // tiles.animations; // Array<AnimationClip>\n  // tiles.scene; // Group\n  // tiles.scenes; // Array<Group>\n  // tiles.cameras; // Array<Camera>\n  // tiles.asset; // Object\n  // ReactDOM.render(\n  //     <Game/>,\n  //     document.getElementById(\"root\")\n  // )\n\n  init();\n  mainLoop();\n});\n\n//# sourceURL=webpack://Demo/./src/index.js?");

/***/ }),

/***/ "./src/loadScene.js":
/*!**************************!*\
  !*** ./src/loadScene.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n// Instantiate a loader\n\nvar loader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_0__[\"GLTFLoader\"]();\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (url) {\n  var onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new Promise(function (resolve, reject) {\n    // Load a glTF resource\n    loader.load( // resource URL\n    url, // called when the resource is loaded\n    resolve, // called while loading is progressing\n    onProgress, // called when loading has errors\n    reject);\n  });\n});\n\n//# sourceURL=webpack://Demo/./src/loadScene.js?");

/***/ }),

/***/ "./src/loadTexture.js":
/*!****************************!*\
  !*** ./src/loadTexture.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n// Instantiate a loader\n\nvar loader = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]();\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (url) {\n  var onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new Promise(function (resolve, reject) {\n    // Load a glTF resource\n    loader.load( // resource URL\n    url, // called when the resource is loaded\n    resolve, // called while loading is progressing\n    onProgress, // called when loading has errors\n    reject);\n  });\n});\n\n//# sourceURL=webpack://Demo/./src/loadTexture.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack://Demo/./src/style.css?");

/***/ })

/******/ });