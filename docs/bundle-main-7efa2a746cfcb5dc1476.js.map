{"version":3,"sources":["webpack://App/webpack/bootstrap","webpack://App/../src/index.js","webpack://App/./src/constants.js","webpack://App/./src/editor/Grid.js","webpack://App/./src/editor/prepareTiles.js","webpack://App/./src/loadScene.js","webpack://App/./src/util/inputToWFC.js","webpack://App/./src/editor/default-tiles.js","webpack://App/./src/util/threeJsThumbnailer.js","webpack://App/./src/editor/TileInstance.js","webpack://App/./src/util/findNamed.js","webpack://App/./src/editor/loadInstanceJSON.js","webpack://App/./src/heightLimit.js","webpack://App/../src/vector.js","webpack://App/./src/loadTexture.js","webpack://App/./src/util/waveFunctionCollapse.js","webpack://App/./src/util/color.js","webpack://App/./src/index.js","webpack://App/./src/util/dump.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","3","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","SIXTH","Math","DEFAULT_CONFIG","width","height","numberOfRings","removeEdges","animatedEasing","renderFirstPassEdges","debug","weightFunction","dx","x1","dy","y1","edgeLength","maxIterations","animating","minTension","findOtherEdge","faces","x0","y0","index","out","count","edge","removeRandomEdges","config","stack","Int32Array","pos","scaled","tmp","getEdgeStack","console","stackPos","eraseEdgesOfFaceInStack","success","code","otherIndex","otherEdge","x2","y2","otherIsOutmostTri","subdivide","firstPassLen","numNodes","tris","quads","calculateNumNodes","nodes","Float64Array","tiles","tilePos","insertNode","isEdge","addTile","n0","insertEdge","n1","found","Error","connect","outmostEdge","firstEdgeIsOutmost","secondEdgeIsOutmost","m0x","m0y","m1x","m1y","m2x","m2y","cx","cy","n2","n3","n4","n5","n6","x3","y3","m3x","m3y","n7","n8","newTiles","numConnections","k","otherNode0","otherNode1","otherNode2","otherNode3","connectTiles","relaxWeighted","graph","tension","edgeCount","centerX","centerY","sumWeight","other","weight","ctx","hw","hh","limit","updateConfig","this","DIRECTIONS","Vector","off","numTris","v0","v1","v2","isOutmost","createHexagonTriangles","start","WATER","SAND","GRASS","FOREST","STONE","ICE","DIRT","UNDEFINED","MATERIAL_NAMES","CASE_NAMES","TAU","PI","PHI","sqrt","TILE_SIZE","numMaterials","Grid","size","scene","materials","offsets","x","y","rotateEvery","rotateCount","flag","group","Group","curr","geo","PlaneBufferGeometry","mat","clone","side","DoubleSide","mesh","Mesh","position","set","add","rotation","material","tx","ty","tile","cleanFn","gridSize","sizeX","sizeZ","rotationIndex","posX","posY","directions","matOff","clean","indexes","Uint32Array","lineDx","lineDy","offset","pattern","instance","setTile","getMaxId","id","idCount","createEmptyThumbnail","canvas","document","createElement","thumbnailWidth","thumbnailHeight","getContext","lineWidth","strokeStyle","fillStyle","min","beginPath","moveTo","lineTo","rect","stroke","fillText","prepareTiles","tilesGLTF","DEFAULT_TILES","raw","variants","sizeY","reachable","children","filter","indexOf","thumbnail","sort","a","b","idCounter","forEach","Array","isArray","thumbNames","objects","idx","threeJsThumbnailer","then","thumbnails","th","unshift","colors","loader","GLTFLoader","url","onProgress","Promise","resolve","reject","load","tmpMask","tileName","tileId","inputToWFC","inputData","weightTargets","maxId","numInts","grid","loadInstanceJSON","last","adjacencies","tileA","tileB","bit","numEntries","changed","numWeights","weights","numAdjacencies","top","right","bottom","left","fill","sum","emptyWeight","names","container","body","appendChild","style","renderer","WebGLRenderer","alpha","setPixelRatio","devicePixelRatio","setSize","domElement","Scene","camera","PerspectiveCamera","light","DirectionalLight","current","images","remove","box","Box3","expandByObject","max","isSmall","dist","pow","up","lookAt","Vector3","updateProjectionMatrix","render","copy","drawImage","thumbName","dispose","removeChild","TileInstance","createObject","variant","random","newObject","scale","findNamed","array","e","instances","rawInstances","notFound","Set","log","heightLimit","w","beach","beachSquared","mountain","mountain_mid","delta","targetLength","TextureLoader","wfcData","logsTable","WEIGHT_TARGETS","tileIdReachable","tmpCount","Uint8Array","calculateEntropy","tileData","tileDataIndex","ground","weightSum","sumWeightTimesLogWeight","maskValue","td_bitmask","log2","waveFunctionCollapse","organicQuads","heightMap","tileDefinitions","tileFactor","t_size","td_size","tileDataFactor","inputToWfc","calculateLogs","createTileIdReachableLookup","oqTiles","heightIndexFactor","h_size","g_size","tmpCountLen","heightIndex0","t_n0","heightIndex1","t_n1","heightIndex2","t_n2","heightIndex3","t_n3","h_ground","td_ground","td_tileId","td_collapsed","emptyNeighbor","t_tile0","emptyOffset","defaultsOffset","td_entropy","prepare","lowCount","choiceCount","remainingWeightSum","tileWasCollapsed","lowest","choices","Infinity","entropy","choice","int","mask","td_walkable","rnd","tileIndex","neighbor","neighborTileDataIndex","first","connectedTile","connectedTileDataIndex","isCollapsed","empty","colorRegExp","checkColor","color","exec","col","parseInt","g","substring","components","controls","water","td_cx","td_cy","td_cut0","td_cut1","td_cut2","td_cut3","nOffset","mOffset","heightFn","z0","distance","noise","noise2D","MAX_HEIGHT","tmpHeight","cutCliffs","tileCuts","cutNodes","tileDataIndex0","tileDataIndex1","t_tile1","tileDataIndex2","t_tile2","tileDataIndex3","t_tile3","cutMask","abs","cut0","cut1","heightMapIndex0","heightMapIndex1","node0","node1","usInOther","next","prevIsCut","nextIsCut","cut","h_height","h_cuts","createScene","OrganicQuads","graphUserData","heightMapFactor","g_x","g_y","tileDataPos","updateCentroids","t_isEdge","findEdgeTile","visited","walkRecursive","has","testWalkability","heightMapPos","nodePos","generateGround","rng","Prando","SimplexNoise","UNDEFINED_COLOR","cubeCamera","sky","skyParameters","updateSun","theta","phi","cos","sin","z","uniforms","normalize","update","init","getElementById","innerWidth","innerHeight","outputEncoding","sRGBEncoding","CubeCamera","background","renderTarget","waterGeometry","MeshStandardMaterial","FrontSide","envMap","texture","roughness","Sky","OrbitControls","maxPolarAngle","target","minDistance","maxDistance","enableDamping","dampingFactor","addEventListener","onWindowResize","geometry","BufferGeometry","vertices","normals","helperVertices","getColor","z1","z2","z3","ax","ay","az","bx","by","bz","cz","nx","ny","nz","f","ground0","ground1","ground2","ground3","setAttribute","Float32BufferAttribute","vertexColors","BufferAttribute","Float32Array","MeshBasicMaterial","Color","depthTest","addHeightMap","Object3D","aspect","mainLoop","time","performance","now","WATER_LIMIT","raf","all","loadScene","loadTexture","marchingSquares","tWaterNormals","dump","obj","level","type","nextLevel","map","find","kid","extractMarchingSquares","wrapS","wrapT","RepeatWrapping"],"mappings":"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","file":"bundle-main-7efa2a746cfcb5dc1476.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t3: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonpApp\"] = window[\"webpackJsonpApp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([46,0]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import now from \"performance-now\"\nimport Vector from \"./vector\";\n\nexport const f_x0 = 0;\nexport const f_y0 = 1;\nexport const f_x1 = 2;\nexport const f_y1 = 3;\nexport const f_x2 = 4;\nexport const f_y2 = 5;\nexport const f_x3 = 6;\nexport const f_y3 = 7;\nexport const f_count = 8;\nexport const f_outmostEdge = 9;\nexport const f_size = 10;\n\nexport const g_x = 0;\nexport const g_y = 1;\nexport const g_isEdge = 2;\nexport const g_count = 3;\nexport const g_edge0 = 4;\nexport const g_edge1 = 5;\nexport const g_edge2 = 6;\nexport const g_edge3 = 7;\nexport const g_edge4 = 8;\nexport const g_edge5 = 9;\nexport const g_size = 10;\n\n\nexport const t_n0 = 0;\nexport const t_n1 = 1;\nexport const t_n2 = 2;\nexport const t_n3 = 3;\nexport const t_isEdge = 4;\nexport const t_tile0 = 5;\nexport const t_tile1 = 6;\nexport const t_tile2 = 7;\nexport const t_tile3 = 8;\nexport const t_size = 9;\n\nconst TAU = Math.PI * 2;\n\nconst SIXTH = TAU / 6;\n\nfunction calculateNumberOfFaces(limit)\n{\n    return 6 * (limit + 1) * (limit + 1);\n}\n\n\nconst DEFAULT_CONFIG = {\n    /** coordinate width */\n    width: 0,\n    /** coordinate height */\n    height: 0,\n    /** number of rings in the hexagon / number of base intersections of hexaxgon */\n    numberOfRings: 5,\n    /** how many percent of the edges shall we attempt to remove? */\n    removeEdges: 50,\n\n    /** if true, the graph will be layouted a bit with every render. If false, the graph relaxation happens at creation */\n    animatedEasing: true,\n\n    /** Set to true to render the original triangles, set to \"merged\" to render the merged triangles before subdivision */\n    renderFirstPassEdges: false,\n\n     /** Set to true to enable some debug logging */\n    debug : false,\n\n    weightFunction : (x0,y0,x1,y1) => {\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        return Math.sqrt(dx * dx + dy * dy);\n    },\n\n    /// MOSTLY INTERNAL CONFIG ////\n    \n    // calculated internally to match the height\n    edgeLength: 80,\n    // number of iterations until we give up (we will drop out due to having reached low energy most likely much sooner)\n    maxIterations: 100,\n    // set to false if the graph is done animated on animatedEasing : true\n    animating: true,\n\n    // Minimum energy at which we stop relaxing the graph\n    minTension: 2\n};\n\nfunction updateConfig(config)\n{\n    config.numFaces = calculateNumberOfFaces(config.numberOfRings)\n    config.firstPassLen = config.numFaces * f_size\n    config.firstPassNumEdges = config.numFaces * 3\n    config.edgeLength = ( Math.min(config.width, config.height) / (config.numberOfRings * 2 + 2)) | 0;\n    config.animating = config.animatedEasing;\n    config.relaxCount = 0;\n}\n\n\nfunction createHexagonTriangles(config)\n{\n\n    const limit = config.numberOfRings;\n\n    //console.log(\"createHexagonTriangles\", limit);\n\n    const DIRECTIONS = [\n        new Vector(\n            Math.cos(0) * config.edgeLength,\n            Math.sin(0) * config.edgeLength\n        ),\n        new Vector(\n            Math.cos(SIXTH) * config.edgeLength,\n            Math.sin(SIXTH) * config.edgeLength\n        ),\n        new Vector(\n            Math.cos(SIXTH * 2) * config.edgeLength,\n            Math.sin(SIXTH * 2) * config.edgeLength\n        ),\n        new Vector(\n            Math.cos(SIXTH * 3) * config.edgeLength,\n            Math.sin(SIXTH * 3) * config.edgeLength\n        ),\n        new Vector(\n            Math.cos(SIXTH * 4) * config.edgeLength,\n            Math.sin(SIXTH * 4) * config.edgeLength\n        ),\n        new Vector(\n            Math.cos(SIXTH * 5) * config.edgeLength,\n            Math.sin(SIXTH * 5) * config.edgeLength\n        )\n    ];\n\n    const faces = new Float64Array(config.firstPassLen);\n\n    let off = 0;\n\n    let count = 0;\n    let numTris = 1;\n    do\n    {\n        for (let i = 0; i < 6; i++)\n        {\n            const v0 = DIRECTIONS[i];\n            const v1 = DIRECTIONS[(i + 1) % 6];\n            const v2 = DIRECTIONS[(i + 2) % 6];\n\n            let pos = v0.copy().scale(count);\n\n            for (let j = 0; j < numTris; j++)\n            {\n                if (j & 1)\n                {\n                    faces[off + f_x0] = (pos.x) | 0;\n                    faces[off + f_y0] = (pos.y) | 0;\n                    faces[off + f_x1] = (pos.x + v1.x) | 0;\n                    faces[off + f_y1] = (pos.y + v1.y) | 0;\n                    faces[off + f_x2] = (pos.x + v2.x) | 0;\n                    faces[off + f_y2] = (pos.y + v2.y) | 0;\n                    faces[off + f_count] = 3;\n                    faces[off + f_outmostEdge] = -1;\n\n                    off += f_size;\n\n                    pos.add(v2);\n                }\n                else\n                {\n\n                    // All tris in the last row all have their edge #1 on the outer edge of the big hexagon\n                    const isOutmost = count === limit;\n\n                    faces[off + f_x0] = (pos.x) | 0;\n                    faces[off + f_y0] = (pos.y) | 0;\n                    faces[off + f_x1] = (pos.x + v0.x) | 0;\n                    faces[off + f_y1] = (pos.y + v0.y) | 0;\n                    faces[off + f_x2] = (pos.x + v1.x) | 0;\n                    faces[off + f_y2] = (pos.y + v1.y) | 0;\n                    faces[off + f_count] = 3;\n                    faces[off + f_outmostEdge] = isOutmost ? 1 : -1;\n\n                    off += f_size;\n                }\n            }\n        }\n\n        numTris += 2;\n\n    } while (count++ < limit);\n\n    return faces;\n}\n\n\nfunction findOtherEdge(faces, x0, y0, x1, y1, index, out)\n{\n    for (let i = 0; i < faces.length; i += f_size)\n    {\n        if (i === index)\n        {\n            continue;\n        }\n\n        // console.log(\"find\", x0, y0, x1, y1, \":\",\n        //     faces[i + f_x0], faces[i + f_y0],\n        //     faces[i + f_x1], faces[i + f_y1],\n        //     faces[i + f_x2], faces[i + f_y2],\n        //     faces[i + f_x3], faces[i + f_y3],\n        // );\n\n        const count = faces[i + f_count];\n        if (\n            faces[i + f_x0] === x1 && faces[i + f_y0] === y1 &&\n            faces[i + f_x1] === x0 && faces[i + f_y1] === y0\n        )\n        {\n            out.index = i;\n            out.edge = 0;\n            return;\n        }\n        if (\n            faces[i + f_x1] === x1 && faces[i + f_y1] === y1 &&\n            faces[i + f_x2] === x0 && faces[i + f_y2] === y0\n        )\n        {\n            out.index = i;\n            out.edge = 1;\n            return;\n        }\n\n        if (count === 3)\n        {\n            if (\n                faces[i + f_x2] === x1 && faces[i + f_y2] === y1 &&\n                faces[i + f_x0] === x0 && faces[i + f_y0] === y0\n            )\n            {\n                out.index = i;\n                out.edge = 2;\n                return;\n            }\n        }\n        else\n        {\n            if (\n                faces[i + f_x2] === x1 && faces[i + f_y2] === y1 &&\n                faces[i + f_x3] === x0 && faces[i + f_y3] === y0\n            )\n            {\n                out.index = i;\n                out.edge = 2;\n                return;\n            }\n\n            if (\n                faces[i + f_x3] === x1 && faces[i + f_y3] === y1 &&\n                faces[i + f_x0] === x0 && faces[i + f_y0] === y0\n            )\n            {\n                out.index = i;\n                out.edge = 3;\n                return;\n            }\n\n        }\n    }\n\n    out.index = -1;\n}\n\n\nconst out = {index: -1, edge: 0};\n\n\nfunction getEdgeStack(config, faces)\n{\n    const length = config.numFaces * 3;\n    const stack = new Int32Array(length);\n\n    let pos = 0;\n    for (let i = 0; i < config.firstPassLen; i += f_size)\n    {\n        const outmostEdge = faces[i + f_outmostEdge];\n\n        const targetIsOutmostFace = outmostEdge >= 0;\n        // we can't remove any of the outmost edges around the big hexagon (and we avoid having an edge triange as\n        // first merged triangle to simplify edge removal\n        if (!targetIsOutmostFace)\n        {\n            const scaled = i << 2;\n            stack[pos++] = scaled ;\n            stack[pos++] = scaled + 1;\n            stack[pos++] = scaled + 2;\n        }\n    }\n\n    // fisher-yates shuffle the stack\n    for (let i  = 0; i < pos - 2; i++)\n    {\n        const j = i + ((Math.random() * pos - i - 1)|0)\n        const tmp = stack[i];\n        stack[i] = stack[j];\n        stack[j] = tmp;\n    }\n    return stack.slice(0, pos);\n}\n\n\nfunction removeRandomEdges(config, faces)\n{\n    const count = (config.firstPassNumEdges * config.removeEdges / 100)|0;\n\n    //console.log(\"remove attempts\", count);\n\n    const stack = getEdgeStack(config, faces);\n\n    if (config.debug)\n    {\n        console.log(\"Shuffled stack\", [ ... stack.slice() ])\n    }\n\n    let stackPos = 0;\n\n\n    const eraseEdgesOfFaceInStack = index => {\n\n        for (let i = stackPos; i < stack.length; i++)\n        {\n            if ((stack[i] >>> 2) === index)\n            {\n                stack[i] = -1;\n            }\n        }\n    }\n\n\n\n    let success = 0;\n\n    // function printEdge(faces, otherIndex, outMostEdge)\n    // {\n    //     const count = faces[otherIndex + f_count];\n    //     const x0 = faces[otherIndex + outMostEdge * 2]\n    //     const y0 = faces[otherIndex + outMostEdge * 2 + 1]\n    //     const x1 = outMostEdge === count -1 ? faces[otherIndex] : faces[otherIndex + (outMostEdge + 1) * 2]\n    //     const y1 = outMostEdge === count -1 ? faces[otherIndex + 1] : faces[otherIndex + (outMostEdge + 1) * 2 + 1]\n    //\n    //\n    //     return x0 + \",\" + y0 + \",\" + x1 + \",\" + y1;\n    // }\n\n    for (let i = 0; i < count; i++)\n    {\n        let code;\n        do\n        {\n            if (stackPos === stack.length)\n            {\n                if (config.debug)\n                {\n                    config.debug && console.log(\"Ran out of removal candidates after successfully removing\", success, \"out of\", count);\n                }\n                // no more valid removals\n                return;\n            }\n            code = stack[stackPos++];\n        } while (code === -1);\n\n\n        const index = code >> 2;\n        const edge = code & 3;\n\n        const x0 = faces[index + edge * 2];\n        const y0 = faces[index + edge * 2 + 1];\n        const x1 = edge === 2 ? faces[index + f_x0] : faces[index + (edge + 1) * 2];\n        const y1 = edge === 2 ? faces[index + f_y0] : faces[index + (edge + 1) * 2 + 1];\n\n        findOtherEdge(faces, x0, y0, x1, y1, index, out)\n        if (out.index >= 0 && faces[out.index + f_count] === 3)\n        {\n            const {index: otherIndex, edge: otherEdge} = out;\n            const x2 = edge === 0 ? faces[index + f_x2] : faces[index + (edge - 1) * 2];\n            const y2 = edge === 0 ? faces[index + f_y2] : faces[index + (edge - 1) * 2 + 1];\n\n            // check if we're merging with an outmost face\n            const outMostEdge = faces[otherIndex + 9];\n            const otherIsOutmostTri = outMostEdge >= 0;\n\n            //const before = printEdge(faces, otherIndex, outMostEdge)\n            // if (otherIsOutmostTri)\n            // {\n            //     console.log(\"OUTMOST edge before split\", printEdge(faces, otherIndex, outMostEdge),\"EDGE CASE\", otherEdge, \"outMostEdge\", outMostEdge)\n            //     console.log(\"face before\", faces.slice(otherIndex, otherIndex + f_size))\n            // }\n\n            faces[otherIndex + 8] = 4;\n            switch (otherEdge)\n            {\n                case 2:\n                    faces[otherIndex + f_x3] = x2;\n                    faces[otherIndex + f_y3] = y2;\n                    break;\n                case 1:\n                    faces[otherIndex + f_x3] = faces[otherIndex + f_x2];\n                    faces[otherIndex + f_y3] = faces[otherIndex + f_y2];\n                    faces[otherIndex + f_x2] = x2;\n                    faces[otherIndex + f_y2] = y2;\n                    break;\n                case 0:\n                    faces[otherIndex + f_x3] = faces[otherIndex + f_x2];\n                    faces[otherIndex + f_y3] = faces[otherIndex + f_y2];\n                    faces[otherIndex + f_x2] = faces[otherIndex + f_x1];\n                    faces[otherIndex + f_y2] = faces[otherIndex + f_y1];\n                    faces[otherIndex + f_x1] = x2\n                    faces[otherIndex + f_y1] = y2;\n\n                    if (otherIsOutmostTri)\n                    {\n                        faces[otherIndex + f_outmostEdge] = 2;\n                    }\n\n                    break;\n\n            }\n            eraseEdgesOfFaceInStack(otherIndex)\n\n            // remove our face\n            faces[index + f_count] = 0;\n\n            success++;\n        }\n        eraseEdgesOfFaceInStack(index)\n\n    }\n\n    config.debug && console.log(\"Successfully removed\", success, \"out of\", count);\n\n    return success;\n}\n\n\nfunction calculateNumNodes(config, faces)\n{\n    let tris = 0;\n    let quads = 0;\n    for (let i = 0; i < config.firstPassLen; i += f_size)\n    {\n        const count = faces[i + f_count];\n\n        if (count === 3)\n        {\n            tris++;\n        }\n        else if (count === 4)\n        {\n            quads++;\n        }\n    }\n\n    //console.log({quads,tris})\n\n    // we divide each quad in 9 nodes and each tri into 7 nodes\n    return quads * 9 + tris * 7;\n}\n\n\n\nfunction connectTiles(config, tiles)\n{\n    const { length } = tiles;\n\n    for (let i=0; i < length; i += t_size)\n    {\n        let numConnections = 0;\n        for (let j = 0; j < 4; j++)\n        {\n            const n0 = tiles[i + t_n0 + j];\n            const n1 = j === 3 ? tiles[i + t_n0 ] : tiles[i + t_n0 + j + 1];\n\n            let otherIndex = -1;\n            for (let k=0; k < tiles.length; k += t_size)\n            {\n                if (k === i)\n                {\n                    continue;\n                }\n\n                const otherNode0 = tiles[k + t_n0];\n                const otherNode1 = tiles[k + t_n1];\n                const otherNode2 = tiles[k + t_n2];\n                const otherNode3 = tiles[k + t_n3];\n\n                // tile edges are all defined in clockwise order, the opposite edge must necessarily walk the two nodes in\n                // the opposite direction\n\n                if (\n                    otherNode1 === n0 && otherNode0 === n1 ||\n                    otherNode2 === n0 && otherNode1 === n1 ||\n                    otherNode3 === n0 && otherNode2 === n1 ||\n                    otherNode0 === n0 && otherNode3 === n1\n                )\n                {\n\n                    otherIndex = k;\n                    numConnections++;\n                    break;\n                }\n            }\n\n            tiles[i + t_tile0 + j] = otherIndex;\n        }\n        tiles[i + t_isEdge] = numConnections === 4 ? 0 : 1;\n    }\n\n    config.debug && console.log(\"TILE GRAPH\", tiles);\n}\n\n\nfunction subdivide(config, faces)\n{\n    const { firstPassLen } = config;\n\n    const numNodes = calculateNumNodes(config, faces);\n\n    const nodes = new Float64Array(numNodes * g_size);\n\n\n    const tiles = new Int32Array(((numNodes / 2)|0) * t_size);\n\n    let pos = 0;\n    let tilePos = 0;\n\n    const insertNode = (x0, y0, isEdge) => {\n\n        x0 |= 0;\n        y0 |= 0;\n\n        for (let i = 0; i < pos; i += g_size)\n        {\n            if (Math.abs(nodes[i] - x0) < 4 && Math.abs(nodes[i + 1] - y0) < 4)\n            {\n                // if we discover an odd face vertex touching the outmost edge, we will\n                // not register that because the odd tris are not marked as having an outmost edge, because they don't, they\n                // only have one vertex on the edge at most\n                // Later we might however return to that node within an outmost edge and we have to make sure that\n                // we take over the isEdge status from such a node\n                if (isEdge && !nodes[i + 2])\n                {\n                    nodes[i + 2] = 1;\n                }\n\n                return i;\n            }\n        }\n\n        const index = pos;\n\n        nodes[pos + g_x] = x0;\n        nodes[pos + g_y] = y0;\n        nodes[pos + g_isEdge] = isEdge ? 1 : 0;\n        nodes[pos + g_count] = 0;\n\n        pos += g_size;\n\n        return index;\n    }\n\n    const addTile = ((n0,n1,n2,n3) => {\n\n        //console.log(\"addTile\", n0, n1, n2, n3, tilePos)\n\n        tiles[tilePos + t_n0] = n0;\n        tiles[tilePos + t_n1] = n1;\n        tiles[tilePos + t_n2] = n2;\n        tiles[tilePos + t_n3] = n3;\n\n        tilePos += t_size;\n    });\n\n    const insertEdge = (n0, n1) => {\n        let count = nodes[n0 + g_count];\n\n        let found = false;\n        for (let i = 0; i < count; i++)\n        {\n            const other = nodes[n0 + g_edge0 + i];\n            if (other === n1)\n            {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n        {\n            if (count >= 6)\n            {\n                throw new Error(\"At most 6 edges per node\")\n            }\n\n            nodes[n0 + g_edge0 + count++] = n1;\n            nodes[n0 + g_count] = count;\n        }\n\n    }\n    const connect = (n0, n1) => {\n\n        insertEdge(n0, n1);\n        insertEdge(n1, n0);\n\n    }\n\n    for (let i = 0; i < firstPassLen; i += f_size)\n    {\n        const count = faces[i + f_count];\n\n        const x0 = faces[i + f_x0]\n        const y0 = faces[i + f_y0]\n        const x1 = faces[i + f_x1]\n        const y1 = faces[i + f_y1]\n        const x2 = faces[i + f_x2]\n        const y2 = faces[i + f_y2]\n\n        const outmostEdge = faces[i + f_outmostEdge ];\n\n        const firstEdgeIsOutmost = outmostEdge === 1;\n        const secondEdgeIsOutmost = outmostEdge === 2;\n\n        if (count === 3)\n        {\n            const m0x = (x0 + x1) / 2;\n            const m0y = (y0 + y1) / 2;\n            const m1x = (x1 + x2) / 2;\n            const m1y = (y1 + y2) / 2;\n            const m2x = (x2 + x0) / 2;\n            const m2y = (y2 + y0) / 2;\n\n            const cx = (x0 + x1 + x2) / 3\n            const cy = (y0 + y1 + y2) / 3\n\n            const n0 = insertNode(x0, y0);\n            const n1 = insertNode(m0x, m0y);\n            const n2 = insertNode(x1, y1, firstEdgeIsOutmost);\n            const n3 = insertNode(m1x, m1y, firstEdgeIsOutmost);\n            const n4 = insertNode(x2, y2, firstEdgeIsOutmost);\n            const n5 = insertNode(m2x, m2y);\n            const n6 = insertNode(cx, cy);\n\n            connect(n0, n1);\n            connect(n1, n6);\n            connect(n6, n5);\n            connect(n5, n0);\n\n            connect(n1, n2);\n            connect(n2, n3);\n            connect(n3, n6);\n            connect(n6, n1);\n\n            connect(n5, n6);\n            connect(n6, n3);\n            connect(n3, n4);\n            connect(n4, n5);\n\n            addTile(n0,n1,n6,n5);\n            addTile(n1,n2,n3,n6);\n            addTile(n5,n6,n3,n4);\n\n        }\n        else if (count === 4)\n        {\n            const x3 = faces[i + f_x3]\n            const y3 = faces[i + f_y3]\n\n            const m0x = (x0 + x1) / 2;\n            const m0y = (y0 + y1) / 2;\n            const m1x = (x1 + x2) / 2;\n            const m1y = (y1 + y2) / 2;\n            const m2x = (x2 + x3) / 2;\n            const m2y = (y2 + y3) / 2;\n            const m3x = (x3 + x0) / 2;\n            const m3y = (y3 + y0) / 2;\n\n            const cx = (x0 + x1 + x2 + x3) / 4\n            const cy = (y0 + y1 + y2 + y3) / 4\n\n            const n0 = insertNode(x0, y0);\n            const n1 = insertNode(m0x, m0y);\n            const n2 = insertNode(x1, y1, firstEdgeIsOutmost);\n            const n3 = insertNode(m1x, m1y, firstEdgeIsOutmost);\n            const n4 = insertNode(x2, y2, firstEdgeIsOutmost || secondEdgeIsOutmost);\n            const n5 = insertNode(m2x, m2y, secondEdgeIsOutmost);\n            const n6 = insertNode(x3, y3, secondEdgeIsOutmost);\n            const n7 = insertNode(m3x, m3y);\n            const n8 = insertNode(cx, cy);\n\n            connect(n0, n1);\n            connect(n1, n2);\n            connect(n2, n3);\n            connect(n3, n4);\n            connect(n4, n5);\n            connect(n5, n6);\n            connect(n6, n7);\n            connect(n7, n0);\n\n            connect(n8, n3);\n            connect(n8, n5);\n            connect(n8, n7);\n            connect(n8, n1);\n\n            addTile(n0,n1,n8,n7);\n            addTile(n1,n2,n3,n8);\n            addTile(n8,n3,n4,n5);\n            addTile(n7,n8,n5,n6);\n        }\n    }\n\n    //const fillRate = (pos / g_size) / numNodes;\n    //console.log(\"SUBDIVIDED: limit = \", numNodes, \", fill rate = \", fillRate);\n\n    console.log(\"TILES: buffer = \", tiles.length, \", used = \" + tilePos)\n\n    const newTiles = tiles.slice(0, tilePos);\n\n    connectTiles(config, newTiles);\n\n    return [nodes.slice(0, pos), newTiles];\n}\n\n\nfunction relaxWeighted(config, graph, maxIterations = 1)\n{\n\n    const {length} = graph;\n\n    for (let i = 0; i < maxIterations; i++)\n    {\n        let tension = 0;\n        for (let j = 0; j < length; j += g_size)\n        {\n            if (!graph[j + g_isEdge])\n            {\n                const x0 = graph[j + g_x]\n                const y0 = graph[j + g_y]\n                const edgeCount = graph[j + g_count]\n\n                let centerX = 0;\n                let centerY = 0;\n                let sumWeight = 0;\n\n                for (let k = 0; k < edgeCount; k++)\n                {\n                    const other = graph[j + 4 + k];\n\n                    const x1 = graph[other];\n                    const y1 = graph[other + 1];\n\n                    const weight = config.weightFunction(x0, y0, x1, y1);\n\n                    centerX += x1 * weight;\n                    centerY += y1 * weight;\n                    sumWeight += weight;\n                }\n\n                const x1 = centerX / sumWeight\n                const y1 = centerY / sumWeight;\n\n                const dx = x1 - x0;\n                const dy = y1 - y0;\n\n                graph[j + g_x] = x1;\n                graph[j + g_y] = y1;\n\n                tension += dx * dx + dy * dy;\n\n            }\n        }\n\n        if (tension < config.minTension)\n        {\n            config.debug && console.log(\"Reached minimal tension\", config.minTension, \"after\", config.relaxCount, \"iterations\")\n            return true;\n        }\n        config.relaxCount++;\n    }\n\n    if (!config.animatedEasing)\n    {\n        config.debug && console.log(\"Stopping after max iterations = \" + config.maxIterations)\n    }\n\n    return false;\n}\n\n\n/**\n * A hexagon filled with quads forming organic shapes.\n */\nclass OrganicQuads {\n    constructor(cfg)\n    {\n\n        const config = {\n            ...DEFAULT_CONFIG,\n            ...cfg\n        }\n\n        updateConfig(config)\n\n        this.config = config;\n\n        const faces = createHexagonTriangles(config);\n\n        if (config.renderFirstPassEdges)\n        {\n            this.faces = config.renderFirstPassEdges !== \"merged\" ? faces.slice() : faces;\n        }\n\n        const start = config.debug && now();\n\n        removeRandomEdges(config, faces)\n\n        config.debug && console.log(\"Edge removal in \" , now() - start, \"ms\")\n\n        const [graph, tiles] = subdivide(config, faces);\n        this.tiles = tiles;\n\n        if (!config.animating)\n        {\n            relaxWeighted(config, graph, config.maxIterations);\n        }\n        //console.log(\"GRAPH f_size\", graph.length / g_size, graph);\n        this.graph = graph;\n\n    }\n\n\n    render = ctx =>\n    {\n        const { config, graph, faces } = this;\n\n\n        ctx.save();\n\n        const hw = config.width / 2;\n        const hh = config.height / 2;\n\n        ctx.translate(hw, hh)\n\n        const {length} = graph;\n\n        ctx.fillStyle = \"#000\";\n        ctx.fillRect(-hw, -hh, config.width, config.height)\n\n        if (config.renderFirstPassEdges)\n        {\n\n            // draw original quads and tris\n\n            ctx.strokeStyle = \"#f00\";\n            ctx.lineWidth = 1;\n\n\n            let outerCount = 0;\n            for (let pos = 0; pos < config.firstPassLen; pos += f_size)\n            {\n                const count = faces[pos + f_count];\n\n                if (count >= 3)\n                {\n\n                    ctx.beginPath();\n                    ctx.moveTo(faces[pos + f_x0 ],faces[pos + f_y0]);\n\n                    for (let i = 1; i < count; i++)\n                    {\n                        ctx.lineTo(faces[pos + i*2],faces[pos +  i*2 + 1]);\n                    }\n\n                    ctx.closePath();\n                    ctx.stroke();\n\n                    const outmostEdge = faces[pos + f_outmostEdge];\n                    if (outmostEdge >= 0)\n                    {\n                        ctx.strokeStyle = \"#fe0\";\n                        ctx.beginPath();\n                        ctx.moveTo(faces[pos + outmostEdge * 2  ],faces[pos + outmostEdge * 2 + 1]);\n\n                        if (outmostEdge === count - 1)\n                        {\n                            ctx.lineTo(faces[pos + f_x0 ],faces[pos + f_y0]);\n                        }\n                        else\n                        {\n                            ctx.lineTo(faces[pos + (outmostEdge + 1 ) * 2  ],faces[pos + (outmostEdge + 1 ) * 2 + 1]);\n                        }\n                        ctx.stroke();\n                        ctx.strokeStyle = \"#f00\";\n\n                        outerCount++;\n\n                    }\n\n                }\n            }\n            //    console.log(\"Number of outer edges\", outerCount)\n\n            //console.log(\"DRAW EDGES\")\n        }\n\n        // ctx.strokeStyle = \"#fff\";\n        // ctx.lineWidth = 1;\n        //\n        //\n        // function drawEdge(x0, y0, node)\n        // {\n        //     const x1 = graph[node + g_x];\n        //     const y1 = graph[node + g_y];\n        //\n        //     ctx.beginPath();\n        //     ctx.moveTo(x0, y0);\n        //     ctx.lineTo(x1, y1);\n        //     ctx.stroke();\n        // }\n        //\n        //\n        // for (let i = 0; i < length; i += g_size)\n        // {\n        //     const x0 = graph[i + g_x];\n        //     const y0 = graph[i + g_y];\n        //     const edgeCount = graph[i + g_count];\n        //\n        //     for (let j = 0; j < edgeCount; j++)\n        //     {\n        //         drawEdge(x0, y0, graph[i + g_edge0 + j])\n        //     }\n        // }\n\n        //ctx.fillStyle = \"#f0f\";\n        //\n        // for (let i = 0; i < length; i += g_size)\n        // {\n        //     const x0 = graph[i + g_x];\n        //     const y0 = graph[i + g_y];\n        //     const isEdge = graph[i + g_isEdge];\n        //\n        //     if (isEdge)\n        //     {\n        //         ctx.fillRect(x0 - 4,  y0 - 4, 8, 8)\n        //     }\n        // }\n\n        // ctx.strokeStyle = \"#f00\";\n        // ctx.lineWidth = 4;\n        //\n        // for (let pos = 0; pos < config.firstPassLen; pos += f_size)\n        // {\n        //     const count = faces[pos + f_count];\n        //     const outmostEdge = faces[pos + f_outmostEdge];\n        //\n        //\n        //     const last = count - 1;\n        //     for (let i=0; i < count; i++)\n        //     {\n        //         if (i === outmostEdge)\n        //         {\n        //             ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n        //         }\n        //         else\n        //         {\n        //             ctx.strokeStyle = \"rgba(0,255,0,0.5)\";\n        //         }\n        //\n        //         ctx.beginPath();\n        //         ctx.moveTo(faces[pos + i * 2], faces[pos + i * 2 + 1]);\n        //         ctx.lineTo(\n        //             i === last ? faces[pos + f_x0 ] : faces[pos + (i+1) * 2],\n        //             i === last ? faces[pos + f_y0 ] : faces[pos + (i+1) * 2 + 1]\n        //         );\n        //         ctx.stroke();\n        //     }\n        // }\n\n        ctx.restore();\n\n        if (config.animating)\n        {\n            if (relaxWeighted(config, graph))\n            {\n                config.animating = false;\n            }\n            //            raf(redrawGraph)\n        }\n    }\n}\n\n\nexport {  Vector }\n\nexport default OrganicQuads\n","export const WATER = 0;\nexport const SAND = 1;\nexport const GRASS = 2;\nexport const FOREST = 3;\nexport const STONE = 4;\nexport const ICE = 5;\nexport const DIRT = 6;\nexport const PACKED_ICE = 7;\nexport const UNDEFINED = 8;\n\nexport const MATERIAL_NAMES = [\n    \"Water\", // WATER\n    \"Sand\", // SAND\n    \"Grass\", // GRASS\n    \"Forest\", // FOREST\n    \"Stone\", // STONE\n    \"Ice\", // ICE\n    \"Dirt\", // DIRT\n    \"Packed_Ice\", // PACKED_ICE\n];\nexport const CASE_NAMES = [\n    null,\n    \"case-1\",\n    \"case-2\",\n    \"case-3\",\n    \"case-4\",\n    \"case-5-1\",\n    \"case-6\",\n    \"case-7\",\n    \"case-8\",\n    \"case-9\",\n    \"case-10-1\",\n    \"case-11\",\n    \"case-12\",\n    \"case-13\",\n    \"case-14\",\n    \"case-15\",\n    \"case-m1\",\n    \"case-m2\",\n    \"case-m3\",\n    \"case-m4\",\n    \"case-5-2\",\n    \"case-10-2\"\n];\nexport const GROUND_COLORS = {\n    [WATER]: [0, 0.4, 0.8],\n    [SAND]: [0.8, 0.8, 0],\n    [GRASS]: [0, 0.7, 0],\n    [DIRT]: [0.5, 0.3, 0.1],\n    [FOREST]: [0.2, 0.5, 0.3],\n    [STONE]: [0.5, 0.5, 0.5],\n    [ICE]: [1, 1, 1],\n    [PACKED_ICE]: [1, 1, 1],\n    [UNDEFINED]: [1, 0, 1]\n}\nconst GROUND_ROUGHNESS = {\n    [WATER]: 0,\n    [SAND]: 1,\n    [GRASS]: 1,\n    [DIRT]: 1,\n    [FOREST]: 1,\n    [STONE]: 0.4,\n    [ICE]: 0.9,\n    [PACKED_ICE]: 0.8,\n    [UNDEFINED]: 0\n}\n\n\nexport const TAU = Math.PI * 2;\n\nexport const PHI = (1 + Math.sqrt(5)) / 2;\n","import { DoubleSide, Group, Mesh, PlaneBufferGeometry, Scene } from \"three\";\nimport { DIRT, TAU } from \"../constants\";\nimport { tileName } from \"../util/inputToWFC\";\n\nexport const TILE_SIZE = 1;\n\nexport const numMaterials = DIRT;\n\nexport default class Grid\n{\n    /**\n     * Construct a new material grid.\n     *\n     * @param {Number} size         edge length of one material field (int)\n     * @param {Scene} [scene]         three.js scene\n     * @param {Array} [materials]     array with materials\n     */\n    constructor(size, scene, materials)\n    {\n        this.scene = scene;\n        this.size = size;\n\n        this.data = new Float64Array(size * size * numMaterials)\n\n        const offsets = new Float64Array(numMaterials * 2);\n        this.offsets = offsets;\n\n\n        let x = -size*TILE_SIZE/2;\n        let y = -size*TILE_SIZE/2;\n\n        let dx = 0;\n        let dy = size * TILE_SIZE;\n\n        let index = 0;\n        let rotateEvery = 1;\n        let rotateCount = rotateEvery;\n        let flag = false;\n\n            const group = new Group();\n            group.name = \"MaterialGrid\"\n\n            for (let curr = 0; curr < numMaterials; curr++)\n            {\n                offsets[index++] = x;\n                offsets[index++] = y;\n\n                //console.log(\"MATERIAL #\", curr, \"at\", x, y);\n\n                if (scene)\n                {\n                    const geo = new PlaneBufferGeometry(TILE_SIZE * size, TILE_SIZE * size, 1, 1);\n                    const mat = materials[curr].clone();\n                    mat.side = DoubleSide;\n                    const mesh = new Mesh(geo, mat);\n                    mesh.name = \"M\" + curr;\n                    mesh.position.set(x, y, 0);\n                    //mesh.rotation.y = -Math.PI\n                    group.add(mesh);\n                }\n\n\n                x += dx;\n                y += dy;\n\n                if (--rotateCount === 0)\n                {\n                    const tmp = dx;\n                    dx = -dy;\n                    dy = tmp;\n\n                    if (flag)\n                    {\n                        rotateEvery++;\n                    }\n                    flag = !flag;\n\n                    rotateCount = rotateEvery;\n                }\n            }\n\n            group.rotation.x = TAU/4;\n\n        if (scene)\n        {\n            this.group = group;\n\n            scene.add(group);\n        }\n\n    }\n\n\n    /**\n     * Sets or clears a tile or multi-tile in the grid. The given position must be a valid location to set a tile of that size.\n     *\n     * @param {Number} material                 material index\n     * @param {Number} tx                       x-position in material\n     * @param {Number} ty                       y-position in material\n     * @param {TileDefinition} tile             tile definition\n     * @param {Number} rotation                 tile rotation 0-3\n     * @param {function|boolean} [cleanFn]      callback to clean other tiles from a given offset. If not given, the method will clear the multi tile on that offset\n     */\n    setTile(material, tx, ty, tile, rotation, cleanFn = null)\n    {\n        const { size : gridSize } = this;\n        const { sizeX, sizeZ } = tile;\n\n        const rotationIndex = rotation * 2;\n\n        let posX = tx + offsets[rotationIndex] * (sizeX - 1);\n        let posY = ty + offsets[rotationIndex + 1] * (sizeZ - 1);\n\n        const dx = directions[rotationIndex];\n        const dy = directions[rotationIndex + 1];\n\n        const matOff = material * gridSize * gridSize;\n\n        const clean = !cleanFn;\n        const indexes = !clean && new Uint32Array(sizeX * sizeZ);\n\n        // correction of line plus rotated vector\n        const lineDx = - dx * sizeX - dy;\n        const lineDy = - dy * sizeZ + dx;\n\n\n        let index = 0;\n        for (let y = 0; y < sizeZ; y++)\n        {\n            for (let x = 0; x < sizeX; x++)\n            {\n                const offset = matOff + posX + posY * gridSize;\n\n                const value = tile.pattern[y * sizeX + x];\n\n                if (clean)\n                {\n                    if (this.data[offset] === value)\n                    {\n                        this.data[offset] = 0;\n                    }\n                }\n                else\n                {\n                    if (this.data[offset] !== 0)\n                    {\n                        if (typeof cleanFn === \"function\")\n                        {\n                            cleanFn(offset);\n                        }\n                    }\n                    indexes[index++] = offset;\n                    this.data[offset] = value;\n                }\n\n                posX += dx;\n                posY += dy;\n            }\n            posX += lineDx;\n            posY += lineDy;\n        }\n\n        return indexes;\n    }\n\n    clearTile(instance)\n    {\n        this.setTile(instance.material, instance.x, instance.y, instance.tile, instance.rotation, null);\n    }\n}\n\nconst offsets = [\n    0,0,\n    1,0,\n    1,1,\n    0,1\n]\n\nconst directions = [\n    1,0,\n    0,1,\n    -1,0,\n    0,-1\n]\n","import { DEFAULT_TILES } from \"./default-tiles\";\nimport threeJsThumbnailer from \"../util/threeJsThumbnailer\";\n\n\nexport function getMaxId(tiles)\n{\n    return tiles[tiles.length - 1].id + tiles[tiles.length - 1].idCount;\n}\n\nfunction createEmptyThumbnail()\n{\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = thumbnailWidth;\n    canvas.height = thumbnailHeight;\n    const ctx = canvas.getContext(\"2d\");\n\n    ctx.lineWidth = 4;\n    ctx.strokeStyle = \"rgba(255,64,64,0.5)\";\n    ctx.fillStyle = \"#fff\";\n\n    const hw = thumbnailWidth * 0.5;\n    const hh = thumbnailHeight * 0.5;\n    const size = Math.min(hh,hw) * 0.3;\n\n    ctx.beginPath();\n    ctx.moveTo(-size + hw,-size + hh);\n    ctx.lineTo( size + hw, size + hh);\n    ctx.moveTo( size + hw,-size + hh);\n    ctx.lineTo(-size + hw, size + hh);\n    ctx.rect(0,0,thumbnailWidth,thumbnailHeight)\n    ctx.stroke();\n\n    ctx.fillText(\"None\", 4, thumbnailHeight - 4);\n    return canvas;\n}\n    \nconst thumbnailWidth = 40;\nconst thumbnailHeight = thumbnailWidth / 0.75;\n\nexport default function prepareTiles(tilesGLTF)\n{\n    const tiles = [];\n\n    let pos = 0;\n    for (let name in DEFAULT_TILES)\n    {\n        if (DEFAULT_TILES.hasOwnProperty(name))\n        {\n            const raw = DEFAULT_TILES[name];\n            const { variants, sizeX = 1, sizeY = 1, sizeZ = 1 } = raw;\n            tiles[pos] = {\n                ... raw,\n                \n                id: -1,\n                idCount: raw.idCount || 1,\n                name,\n                sizeX,\n                sizeY,\n                sizeZ,\n                reachable: raw.reachable || false,\n                pattern: raw.pattern ? raw.pattern.slice() : null,\n                variants: tilesGLTF ? tilesGLTF.scene.children.filter(o => variants.indexOf(o.name) >= 0) : variants,\n                thumbnail: null\n            };\n            pos++;\n        }\n    }\n\n    tiles.sort((a, b) => a.name === b.name ? 0 : a.name < b.name ? -1 : 1);\n\n    // provide ids\n    let idCounter = 1;\n    tiles.forEach(t => {\n\n        const { name, idCount, pattern, sizeX, sizeZ } = t;\n\n        t.id = idCounter;\n        idCounter += idCount;\n\n        if (idCount > 1)\n        {\n            if (!pattern || !Array.isArray(pattern))\n            {\n                throw new Error(\"Tile '\" + name + \"': tiles with idCount > 1 must define a pattern\");\n            }\n\n            const size = sizeX * sizeZ;\n            if (pattern.length !== size)\n            {\n                throw new Error(\"Tile '\" + name + \"': Pattern must be \" + sizeX + \" x \" + sizeZ + \" = \" + size + \" elements long: \" + pattern);\n            }\n\n            for (let i = 0; i < pattern.length; i++)\n            {\n                pattern[i] += t.id;\n            }\n        }\n        else\n        {\n            // create 1x1 \"pattern\"\n            t.pattern = [ t.id ];\n        }\n    });\n\n    if (tilesGLTF)\n    {\n        const thumbNames = [];\n        const objects = [];\n\n        tiles.forEach((t, idx) => {\n            thumbNames[idx] = t.name;\n            objects[idx] = t.variants[0];\n        });\n\n        //console.log({objects, thumbNames, tiles})\n\n        return threeJsThumbnailer(\n            objects,\n            thumbnailWidth,\n            thumbnailHeight,\n            thumbNames\n        ).then(thumbnails => {\n\n            thumbnails.forEach((th, idx) => tiles[idx].thumbnail = th);\n\n            tiles.unshift({\n                id: 0,\n                idCount: 1,\n                name: \"empty\",\n                variants: [],\n                sizeX: 1,\n                sizeY: 0.1,\n                sizeZ: 1,\n                thumbnail: createEmptyThumbnail(),\n                pattern: [0]\n            });\n\n            return tiles;\n        })\n    }\n    else\n    {\n        tiles.unshift({\n            id: 0,\n            idCount: 1,\n            name: \"empty\",\n            variants: [],\n            sizeX: 1,\n            sizeY: 0.1,\n            sizeZ: 1,\n            reachable:false,\n            colors: [\"#000\"],\n            thumbnail: null\n        });\n\n\n        return tiles;\n    }\n\n}\n","\n// Instantiate a loader\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\n\nconst loader = new GLTFLoader();\n\nexport default function(url, onProgress = null)\n{\n    return new Promise(((resolve, reject) => {\n        // Load a glTF resource\n        loader.load(\n            // resource URL\n            url,\n            // called when the resource is loaded\n            resolve,\n            // called while loading is progressing\n            onProgress,\n            // called when loading has errors\n            reject\n        );\n\n    }))\n}\n","import Grid, { numMaterials } from \"../editor/Grid\";\nimport loadInstanceJSON from \"../editor/loadInstanceJSON\";\nimport { MATERIAL_NAMES } from \"../constants\";\nimport { getMaxId } from \"../editor/prepareTiles\";\n\n\n\nexport function tileName(tiles, tileId)\n{\n    for (let i = 0; i < tiles.length; i++)\n    {\n        const { name, id, idCount} = tiles[i];\n\n        if (tileId === id)\n        {\n            return name;\n        }\n\n        if (tileId > id && tileId < id + idCount)\n        {\n            return name + \"-\" + (tileId - id + 1);\n        }\n    }\n\n    return \"ERR:\" + tileId;\n}\n\nlet tmpMask;\n\n\n\n\nexport default function inputToWFC(inputData, size, tiles, weightTargets)\n{\n    const maxId = getMaxId(tiles);\n\n    // how many ints do we need to express a bitmask of with all possible tile states?\n    const numInts = (maxId + 31) >> 5;\n\n    if (!tmpMask || tmpMask.length < numInts)\n    {\n        tmpMask = new Uint32Array(numInts);\n    }\n\n    const grid = new Grid(size);\n    loadInstanceJSON(inputData, tiles, grid);\n\n    let index = 0;\n    const last = size - 1;\n\n    const  add = (adjacencies, mat, tileA, tileB) =>\n    {\n        const index = tileB >> 5;\n        const bit = 1 << (tileB - (index << 5));\n\n        const offset = mat * numEntries * numInts + tileA * numInts + index;\n        const value = adjacencies[offset ];\n        const changed = value | bit;\n        if (value !== changed)\n        {\n            adjacencies[offset ] = changed;\n\n            //console.log(MATERIAL_NAMES[mat], \":\", tileName(tiles, tileA), \" -> \", tileName(tiles, tileB), { index, bit} )\n        }\n    }\n\n    const numEntries = maxId + 1;\n\n    const numWeights = numMaterials * numEntries;\n    const weights = new Uint32Array( numWeights);\n\n    const numAdjacencies = numMaterials * numEntries * numInts;\n    const adjacencies = new Uint32Array(numAdjacencies);\n\n    for (let mat = 0; mat < numMaterials; mat++)\n    {\n        for (let y=0; y < size; y++)\n        {\n            for (let x = 0; x < size; x++)\n            {\n                const tileId = grid.data[index];\n\n                if (tileId !== 0)\n                {\n                    weights[mat * numEntries + 1 + tileId]++;\n                }\n\n                const top = y === 0 ? 0 : grid.data[index - size];\n                const right = x === last ? 0 : grid.data[index + 1];\n                const bottom = y === last ? 0 : grid.data[index + size];\n                const left = x === 0 ? 0 : grid.data[index - 1];\n\n                add(adjacencies, mat, tileId, top)\n                add(adjacencies, mat, tileId, right)\n                add(adjacencies, mat, tileId, bottom)\n                add(adjacencies, mat, tileId, left)\n                index++;\n            }\n        }\n    }\n\n\n    index = 0;\n    for (let i=0; i < numMaterials; i++)\n    {\n        tmpMask.fill(0)\n        let sum = 0;\n        for (let j = 0; j < maxId; j++)\n        {\n            const value = weights[index + 1 + j];\n            if (value > 0 || j === 0)\n            {\n                sum += value;\n\n                const index = j >> 5;\n                const bit = 1 << (j - (index << 5));\n                tmpMask[index] |= bit;\n            }\n        }\n        const offset = i * numEntries * numInts + maxId * numInts;\n\n        if (sum === 0)\n        {\n            weights[index + 1] = 1;\n            weights[index] = 1;\n\n            tmpMask[0] |= 1;\n\n        }\n        else\n        {\n            const r = weightTargets[i] / ( 1- weightTargets[i])\n\n            const emptyWeight = sum * r;\n            weights[index + 1] = emptyWeight;\n            weights[index] = sum + emptyWeight;\n        }\n\n        adjacencies.set(tmpMask, offset);\n\n        index += numEntries\n    }\n\n\n    return {\n        weights,\n        adjacencies\n    };\n}\n","import { Object3D } from \"three\"\n\n/**\n * @typedef {Object} TileDefinition\n *\n * @property {Array<Object3D>} variants         imported variants objects for this tile\n * @property {Number} id                        tile id. For multi-tiles the id of the upper left tile in rotation 0.\n * @property {Number} size                      tile size. default is 1\n * @property {HTMLCanvasElement} thumbnail      generated thumbnail as canvas\n *\n */\n\n\n\nexport const DEFAULT_TILES = {\n        \"cactus\": {\n            \"variants\": [\"cactus_short\", \"cactus_tall\"],\n            \"colors\" : [ \"#0c0\"]\n        },\n        \"flower\": {\n            \"variants\": [\n                \"flower_purpleA\",\n                \"flower_purpleB\",\n                \"flower_purpleC\",\n                \"flower_redA\",\n                \"flower_redB\",\n                \"flower_redC\",\n                \"flower_yellowA\",\n                \"flower_yellowB\",\n                \"flower_yellowC\"\n            ],\n            \"colors\" : [ \"#ff0\"]\n        },\n        \"stone_large\": {\n            \"variants\": [\"stone_largeD\", \"stone_largeE\", \"stone_largeF\"],\n            \"colors\" : [ \"#eee\"]\n        },\n        \"stone_small\": {\n            \"variants\": [\"stone_smallD\"],\n            \"colors\" : [ \"#888\"]\n        },\n        \"palm_tree\": {\n            \"variants\": [\"tree_palmDetailedTall\", \"tree_palmShort\", \"tree_palmTall\"],\n            \"colors\" : [ \"#8c0\"]\n        },\n        \"pine\": {\n            \"variants\": [\"tree_pineRoundD\", \"tree_pineTallC_detailed\", \"tree_pineTallD\"],\n            \"colors\" : [ \"#480\"]\n        },\n        \"tree_plateau\": {\n            \"variants\": [\"tree_plateau\"],\n            \"colors\" : [ \"#482\"]\n        },\n        \"tree_tall_dark\": {\n            \"variants\": [\"tree_tall_dark\"],\n            \"colors\" : [ \"#360\"]\n        },\n        \"tree_thin\": {\n            \"variants\": [\"tree_thin\"],\n            \"colors\" : [ \"#684\"]\n        },\n        \"house\": {\n            \"variants\": [\"House\"],\n            \"sizeX\" : 3,\n            \"sizeY\" : 2,\n            \"sizeZ\" : 3,\n            \"reachable\": true,\n            \"colors\" : [ \"#f00\", \"#00f\"],\n\n            \"idCount\" : 2,\n            \"pattern\" : [\n                1,1,1,\n                1,0,1,\n                1,1,1\n            ]\n        }\n    }\n;\n\n","import { Box3, Color, DirectionalLight, Object3D, PerspectiveCamera, Scene, Vector3, WebGLRenderer } from \"three\"\n\n\n\n/**\n * Takes an array of three.js objects and resolves to an array of#\n * canvases containing thumbnails\n *\n * @param {Array<Object3D>} objects     array of objects\n * @param {Number} width                thumbnail image width\n * @param {Number} height               thumbnail image height\n * @param {Array<String>} [names]        optional array of names\n * @return {Promise<Array<HTMLCanvasElement>>}\n */\nexport default function threeJsThumbnailer(objects, width, height, names) {\n    return new Promise(\n        resolve => {\n\n            const canvases = [];\n\n            const container = document.createElement(\"div\");\n            document.body.appendChild(container)\n            container.style.position = \"absolute\";\n            container.style.top = \"0px\";\n            container.style.left = \"-10000px\";\n\n            const renderer = new WebGLRenderer({\n                alpha: true\n            });\n            renderer.setPixelRatio(window.devicePixelRatio);\n            renderer.setSize(width, height);\n\n            container.appendChild(renderer.domElement);\n\n            const scene = new Scene();\n            //scene.background = new Color(\"#888\")\n\n            const camera = new PerspectiveCamera(55, width / height, 0.1, 100);\n\n            const light = new DirectionalLight(\"#fff8d5\", 1.4);\n            light.position.set(0, 3, -1.5)\n            scene.add(light);\n\n            const images = [];\n\n            let current;\n            for (let i = 0; i < objects.length; i++)\n            {\n                if (current)\n                {\n                    scene.remove(current)\n                }\n\n                current = objects[i].clone();\n\n                const box = new Box3();\n                box.expandByObject(current)\n\n                const size = Math.max(\n                    box.max.x - box.min.x,\n                    box.max.y - box.min.y\n                )\n\n                const isSmall = size < 1.5;\n                const dist = isSmall ? Math.pow(size, 0.9) * 1.2 : size * 1.5;\n                camera.up.set(0, 1, 0);\n\n                //console.log(current.name, direction, box)\n                camera.position.set(0, box.max.y * (isSmall ? 1.1 : 0.9), -dist);\n                camera.lookAt(new Vector3(0, (box.max.y + box.min.y) / (isSmall ? 2 : 4), 0));\n                camera.updateProjectionMatrix();\n\n                current.position.set(0, 0, 0)\n                scene.add(current);\n\n                renderer.render(scene, camera);\n\n                const copy = document.createElement(\"canvas\")\n\n                copy.width = width;\n                copy.height = height;\n\n                const ctx = copy.getContext(\"2d\");\n                ctx.drawImage(\n                    renderer.domElement,\n                    0,0\n                );\n                ctx.strokeStyle = \"rgba(255,255,255,0.4)\";\n                ctx.fillStyle = \"#fff\";\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.rect(0,0,width, height)\n                ctx.stroke();\n\n                const thumbName = names ? names[i] : current.name;\n                ctx.fillText(thumbName, 4, height - 4)\n\n\n                // const img = new Image();\n                // img.src = renderer.domElement.toDataURL();\n                //\n                // images.push(img);\n                images.push(copy);\n            }\n\n            resolve(images);\n\n            scene.dispose();\n            renderer.dispose();\n\n            document.body.removeChild(container)\n        }\n    )\n}\n","import { TILE_SIZE } from \"./Grid\";\n\nimport { Scene, Vector3 } from \"three\"\nimport { TAU } from \"../constants\";\n\n\nlet idCounter = 0;\n\nexport default class TileInstance\n{\n    scene;\n    tile;\n    position;\n    object = null;\n    indexes = null;\n\n    /**\n     *  Creates a new tile instance\n     *\n     * @param {Scene} scene             three.js scene\n     * @param {TileDefinition} tile     tile definition\n     * @param {Vector3} position        position of the tile\n     * @param {number} rotation         tile rotation (0-3)\n     * @param {Number} material         material index\n     * @param {Number} x                tile x\n     * @param {Number} y                tile y\n     */\n    constructor(scene, tile, position, rotation, material, x, y)\n    {\n        this.id = ++idCounter;\n\n        this.scene = scene;\n        this.tile = tile;\n        this.position = position.clone();\n        this.rotation = rotation;\n\n        this.material = material;\n        this.x = x;\n        this.y = y;\n\n        if (scene)\n        {\n            this.createObject();\n        }\n    }\n\n    createObject()\n    {\n        const { tile, scene, position, rotation } = this;\n        const { variants } = tile;\n\n        this.variant = Math.random() * variants.length|0;\n\n        const newObject = variants[this.variant].clone();\n        newObject.scale.set(TILE_SIZE, TILE_SIZE, TILE_SIZE)\n        newObject.position.copy(position)\n\n        newObject.rotation.y = TAU * rotation / 4;\n\n        this.object = newObject;\n        scene.add(newObject);\n    }\n\n    removeObject()\n    {\n        const { scene, object } = this;\n\n        if (object)\n        {\n            scene.remove(object);\n            this.object = null;\n        }\n    }\n\n}\n","/**\n * Finds a named element\n *\n * @param array     array of elements\n * @param name      name\n * @return {?Object} element or null\n */\nexport default function findNamed(array, name)\n{\n    for (let i = 0; i < array.length; i++)\n    {\n        const e = array[i];\n        if (e.name === name)\n        {\n            return e;\n        }\n    }\n    return null;\n}\n","import TileInstance from \"./TileInstance\";\nimport { Vector3, Scene } from \"three\";\nimport findNamed from \"../util/findNamed\";\n\n\n/**\n * Loads the input instance data from a JSON file\n *\n * @param {Object} data                     raw JSON data\n * @param {Array<TileDefinition>} tiles     array of tile definition\n * @param {Grid} grid                       grid instance\n * @param {Set<TileInstance>} [instances]   set of tile instances\n * @param {Scene} [scene]                   scene\n */\nexport default function loadInstanceJSON(data, tiles, grid, instances, scene)\n{\n    const { instances: rawInstances } = data;\n\n    const notFound = new Set();\n\n    for (let i = 0; i < rawInstances.length; i++)\n    {\n        const raw = rawInstances[i];\n\n        const tile = findNamed(tiles, raw.name);\n\n        if (tile)\n        {\n            const instance = new TileInstance(\n                scene,\n                tile,\n                new Vector3(raw.position[0], raw.position[1], raw.position[2]),\n                (Math.random() * 4)|0,\n                raw.material,\n                raw.x,\n                raw.y\n            );\n\n            instance.variant = (Math.random() * tile.variants.length)|0;\n\n            instance.indexes = grid.setTile(instance.material, instance.x, instance.y, instance.tile, instance.rotation, true);\n\n            if (instances)\n            {\n                instances.add(instance);\n            }\n        }\n        else\n        {\n            notFound.add(raw.name);\n        }\n    }\n\n    if (notFound.size > 0)\n    {\n        console.log(\"Could not find some tiles: \", notFound)\n    }\n\n}\n","export function heightLimit(x, w = 0)\n{\n    const beach = 0.05;\n    const beachSquared = beach * beach;\n\n    const mountain = w ? 0.4 : 0.6;\n    const mountain_mid = w ? 0.75 : 0.5;\n\n    if (x < beach)\n    {\n        x = beach - x;\n\n        return beachSquared - x * x;\n    }\n    else if (x < mountain)\n    {\n        x = x - beach;\n        const delta = mountain - beach;\n        return beachSquared + (x * x * (mountain_mid - beachSquared) / (delta * delta));\n    }\n    else\n    {\n        x = 1 - x;\n\n        const delta = 1 - mountain;\n\n        return 1 - x * x * x * (1 - mountain_mid) / (delta * delta * delta);\n    }\n}\n","const sqrt = Math.sqrt;\n\nclass Vector\n{\n    constructor(x,y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Returns a copy of this vector.\n     *\n     * @returns {Vector} copy\n     */\n    copy()\n    {\n        return new Vector(this.x,this.y);\n    }\n\n    /**\n     * Adds to this vector\n     *\n     * @param x     {number|Vector} x coordinate or a vector\n     * @param y     {number?} y coordinate, ignored if x is a vector\n     * @returns {Vector} this vector\n     */\n\n    add(x,y)\n    {\n        if (typeof x === \"number\")\n        {\n            this.x += x;\n            this.y += y;\n        }\n        else\n        {\n            this.x += x.x;\n            this.y += x.y;\n        }\n\n        return this;\n    }\n\n    /**\n     * Subtracts from this vector\n     *\n     * @param x     {number|Vector} x coordinate or a vector\n     * @param y     {number?} y coordinate, ignored if x is a vector\n     * @returns {Vector} this vector\n     */\n    subtract(x,y)\n    {\n        if (typeof x === \"number\")\n        {\n            this.x -= x;\n            this.y -= y;\n        }\n        else\n        {\n            this.x -= x.x;\n            this.y -= x.y;\n        }\n\n        return this;\n    }\n\n    /**\n     * Scales the vector by a planar number.\n     *\n     * @param n     scale\n     * @returns {Vector} this vector, scaled\n     */\n    scale(n)\n    {\n        this.x *= n;\n        this.y *= n;\n\n        return this;\n    }\n\n    /**\n     * Length of this vector\n     *\n     * @returns {number}    length\n     */\n    length()\n    {\n        const { x, y } = this;\n        return sqrt(x*x+y*y);\n    }\n\n    /**\n     * Scales the vector to normal length or a specified length\n     *\n     * @param targetLength      {number?} target length of the vector (default is 1, the normal vector length)\n     *\n     * @returns {Vector}\n     */\n    norm(targetLength = 1)\n    {\n        return this.scale(targetLength / this.length());\n    }\n\n    /**\n     * Rotate vector 90 degrees clockwise.\n     *\n     * @returns {Vector}\n     */\n    rotateClockwise()\n    {\n        const { x, y } = this;\n\n        //noinspection JSSuspiciousNameCombination\n        this.x = y;\n        this.y = -x;\n\n        return this;\n    }\n\n    /**\n     * Rotate vector 90 degrees counter clockwise.\n     *\n     * @returns {Vector}\n     */\n    rotateCounterClockwise()\n    {\n        const { x, y } = this;\n\n        this.x = -y;\n        //noinspection JSSuspiciousNameCombination\n        this.y = x;\n\n        return this;\n    }\n\n    /**\n     * Sets the coordinates of this vector\n     *\n     * @param x     {number|Vector} x coordinate or a vector\n     * @param y     {number?} y coordinate, ignored if x is a vector\n     * @returns {Vector} this vector\n     */\n    set(x,y)\n    {\n        if (typeof x === \"number\")\n        {\n            this.x = x;\n            this.y = y;\n        }\n        else\n        {\n            this.x = x.x;\n            this.y = x.y;\n        }\n\n    }\n}\n\nexport default Vector;\n","// Instantiate a loader\nimport { TextureLoader } from \"three\";\n\nconst loader = new TextureLoader();\n\nexport default function(url, onProgress = null)\n{\n    return new Promise(((resolve, reject) => {\n        // Load a glTF resource\n        loader.load(\n            // resource URL\n            url,\n            // called when the resource is loaded\n            resolve,\n            // called while loading is progressing\n            onProgress,\n            // called when loading has errors\n            reject\n        );\n\n    }))\n}\n","import { getMaxId } from \"../editor/prepareTiles\";\nimport { numMaterials } from \"../editor/Grid\";\nimport { ICE, MATERIAL_NAMES, WATER } from \"../constants\";\nimport inputToWfc, { tileName } from \"./inputToWFC\";\nimport inputData from \"../../input.json\";\nimport {\n    h_ground,\n    h_size,\n    td_bitmask,\n    td_collapsed,\n    td_entropy,\n    td_ground,\n    td_size,\n    td_tileId,\n    td_walkable\n} from \"../index\";\nimport { g_size, t_n0, t_n1, t_n2, t_n3, t_size, t_tile0 } from \"@fforw/organic-quads\";\nimport printMask from \"./printMask\";\n\n\nconst WEIGHT_TARGETS = [\n    1, // WATER\n    0.8, // SAND\n    0.3, // GRASS\n    0.1, // FOREST\n    0.6, // STONE\n    1, // ICE\n    1, // DIRT\n    1, // PACKED_ICE\n];\n\nfunction calculateLogs(tiles, weights)\n{\n    const maxId = getMaxId(tiles);\n    const numEntries = maxId + 1;\n    const logsTable = new Float64Array(weights) ;\n\n    for (let i=0; i < numMaterials; i++)\n    {\n        const off = i * numEntries + 1;\n        for (let j = 0; j < maxId; j++)\n        {\n            const value = weights[off + j];\n            if (value > 0)\n            {\n                logsTable[off + j] = Math.log2(value) * value;\n            }\n        }\n    }\n\n    //console.log({weights,logsTable});\n\n    return logsTable;\n}\n\nlet tiles, wfcData, logsTable;\n\n\n\nconst tmpCount = new Uint8Array(numMaterials);\n\nlet tmpMask;\n\n\nfunction calculateEntropy(tileData, tileDataIndex, weights, numInts, maxId, ground)\n{\n    const numEntries = maxId + 1;\n\n    let weightSum = 0;\n    let sumWeightTimesLogWeight = 0;\n    for (let j = 0; j < numInts; j++)\n    {\n        const maskValue = tileData[tileDataIndex + td_bitmask + j];\n\n        let bit = 1;\n        let tileId = 0;\n        while (bit)\n        {\n            if ((maskValue & bit))\n            {\n                const offset = ground * numEntries + 1 + tileId;\n                const weight = weights[offset];\n                const weightTimesLogWeight = logsTable[offset];\n\n                weightSum += weight;\n                sumWeightTimesLogWeight += weightTimesLogWeight;\n            }\n            bit <<= 1\n            tileId++;\n        }\n    }\n\n    /*\n        shannon_entropy_for_square = log(sum(weight)) - (sum( weight * log(weight) ) / sum(weight))\n    */\n\n    const entropy = Math.log2(weightSum) - (sumWeightTimesLogWeight / weightSum);\n\n    //console.log(\"Entropy for #\", tileDataIndex / td_size, MATERIAL_NAMES[ground], \" = \", entropy )\n\n    return entropy;\n}\n\n\nfunction prepare(oqTiles, heightMap, tileData, tileDefinitions)\n{\n    const { weights, adjacencies } = wfcData;\n\n    const heightIndexFactor = h_size / g_size;\n\n    const tileDataFactor = td_size / t_size;\n\n    const maxId = getMaxId(tileDefinitions);\n    const numInts = (maxId + 31) >> 5;\n\n    const numEntries = maxId + 1;\n\n    if (td_bitmask + numInts > td_size)\n    {\n        throw new Error(\"more td_bitmaskN values needed\");\n    }\n\n    if (!tmpMask)\n    {\n        tmpMask = new Uint32Array(numInts)\n    }\n\n    const { length : tmpCountLen } = tmpCount;\n    let tileDataIndex = 0;\n    for (let i = 0; i < oqTiles.length; i += t_size)\n    {\n        // node indizes for our quad\n        const n0 = oqTiles[i + t_n0];\n        const n1 = oqTiles[i + t_n1];\n        const n2 = oqTiles[i + t_n2];\n        const n3 = oqTiles[i + t_n3];\n\n        // equivalent height map indizes\n        const heightIndex0 = n0 * heightIndexFactor;\n        const heightIndex1 = n1 * heightIndexFactor;\n        const heightIndex2 = n2 * heightIndexFactor;\n        const heightIndex3 = n3 * heightIndexFactor;\n\n        tmpCount.fill(0);\n\n        tmpCount[heightMap[heightIndex0 + h_ground]]++;\n        tmpCount[heightMap[heightIndex1 + h_ground]]++;\n        tmpCount[heightMap[heightIndex2 + h_ground]]++;\n        tmpCount[heightMap[heightIndex3 + h_ground]]++;\n\n        let max = 0;\n        let ground = -1;\n        for (let j = 0; j < tmpCountLen; j++)\n        {\n            const value = tmpCount[j];\n            if (value > max)\n            {\n                max = tmpCount[j];\n                ground = j;\n            }\n        }\n        tileData[tileDataIndex + td_ground ] = ground;\n\n        // if we have no ground majority or if we have ground that's always empty\n        if (ground === ICE || ground === WATER)\n        {\n            // store empty tile id and mark as collapsed\n            tileData[tileDataIndex + td_tileId ] = 0;\n            tileData[tileDataIndex + td_collapsed ] = 1;\n        }\n        else\n        {\n            let emptyNeighbor = false;\n            for (let j = 0; j < 4; j++)\n            {\n                const other = oqTiles[i + t_tile0 + j];\n                if (other >= 0)\n                {\n                    const otherTileDataIndex = other * tileDataFactor;\n\n                    if (tileData[otherTileDataIndex + td_collapsed ])\n                    {\n                        emptyNeighbor = true;\n                        break;\n                    }\n                }\n            }\n\n            const emptyOffset = ground * numEntries * numInts;\n            const defaultsOffset = ground * numEntries * numInts + maxId * numInts;\n            for (let j = 0; j < numInts; j++)\n            {\n                // if we have an empty neighbor, use empty's adjacencies as mask, otherwise use the default mask\n                tileData[tileDataIndex + td_bitmask + j] = emptyNeighbor ?\n                    adjacencies[emptyOffset + j] :\n                    adjacencies[defaultsOffset + j];\n            }\n\n            //console.log(\"Initial Mask for #\", tileDataIndex / td_size, \" = \", tileData[tileDataIndex + td_bitmask])\n\n            tileData[tileDataIndex + td_entropy] = calculateEntropy(tileData, tileDataIndex, weights, numInts, maxId, ground)\n        }\n\n        tileDataIndex += td_size;\n    }\n\n}\n\n\nfunction printTileDataMask(tileDefinitions, tileData, tileDataIndex, numInts)\n{\n    let tileId = 0;\n    let buf = \"\";\n    for (let int = 0; int < numInts; int++)\n    {\n        let bit = 1;\n        while (bit)\n        {\n            if (tileData[tileDataIndex + td_bitmask + int] & bit)\n            {\n                buf += tileName(tileDefinitions, tileId) + \", \";\n\n            }\n            bit <<=1;\n            tileId++;\n        }\n    }\n\n    return buf;\n}\n\n\nlet tileIdReachable;\n\n\nfunction createTileIdReachableLookup(maxId, tileDefinitions)\n{\n    const tileIdReachable = new Uint8Array(maxId);\n    for (let i = 0; i < tileDefinitions.length; i++)\n    {\n        const {id, idCount, reachable} = tileDefinitions[i];\n\n        if (reachable)\n        {\n            for (let j = 0; j < idCount; j++)\n            {\n                tileIdReachable[id + j] = 1;\n            }\n\n        }\n    }\n\n    return tileIdReachable;\n}\n\n\nexport default function waveFunctionCollapse(organicQuads, heightMap, tileData, tileDefinitions)\n{\n    const { tiles } = organicQuads;\n\n    //debugger;\n    const maxId = getMaxId(tileDefinitions);\n    const numInts = (maxId + 31) >> 5;\n    const numEntries = maxId + 1;\n\n    const tileFactor = t_size / td_size;\n    const tileDataFactor = td_size / t_size;\n\n    if (!wfcData)\n    {\n        wfcData = inputToWfc(inputData, 12, tileDefinitions, WEIGHT_TARGETS);\n\n        // const { adjacencies } =  wfcData;\n        //\n        // for (let ground = 0; ground < numMaterials; ground++)\n        // {\n        //     console.log(\"DEFAULTS on \", MATERIAL_NAMES[ground], \": \", printMask(tileDefinitions, adjacencies, maxId, numInts, ground, maxId));\n        // }\n\n        logsTable = calculateLogs(tileDefinitions, wfcData.weights);\n        tileIdReachable = createTileIdReachableLookup(maxId, tileDefinitions);\n    }\n\n    const { weights, adjacencies } = wfcData;\n\n    prepare(tiles, heightMap, tileData, tileDefinitions)\n\n\n\n    let tileWasCollapsed = false;\n\n    let count = (tiles.length / t_size);\n    let lowest = [];\n    let lowCount;\n    let choices = [];\n    let choiceCount;\n    let remainingWeightSum;\n\n\n    do\n    {\n        lowCount = 0;\n        let min = Infinity;\n\n        for (let i = 0; i < tileData.length; i += td_size)\n        {\n            if (!tileData[i + td_collapsed])\n            {\n                const entropy = tileData[i + td_entropy];\n\n                //console.log(\"entropy < min\", entropy, min)\n                if (entropy < min)\n                {\n                    min = entropy;\n                    lowest[0] = i;\n                    lowCount = 1;\n                }\n                else if (entropy === min)\n                {\n                    lowest[lowCount++] = i;\n                }\n            }\n        }\n\n        if (min === Infinity)\n        {\n            return;\n        }\n\n\n        let tileDataIndex;\n        if (lowCount === 1)\n        {\n            tileDataIndex = lowest[0];\n        }\n        else\n        {\n            tileDataIndex = lowest[(Math.random() * lowCount)|0]\n        }\n\n\n        let choice = null;\n        let tileId = 0;\n        const ground = tileData[tileDataIndex + td_ground];\n\n\n        choiceCount = 0;\n        remainingWeightSum = 0;\n        for (let int=0; int < numInts; int++)\n        {\n            const mask = tileData[tileDataIndex + td_bitmask + int];\n\n            let bit = 1;\n            while (bit)\n            {\n                if (mask & bit)\n                {\n\n                    if (tileData[tileDataIndex + td_walkable] || !tileIdReachable[tileId])\n                    {\n                        const weight = weights[ground * numEntries + 1 + tileId];\n\n                        choices[choiceCount++] = weight;\n                        choices[choiceCount++] = tileId;\n\n                        remainingWeightSum += weight;\n                    }\n\n                }\n\n\n                bit <<=1;\n                tileId++;\n            }\n        }\n\n        // choose from remaining choices\n\n        if (choiceCount === 1)\n        {\n            choice = choices[1];\n        }\n        else\n        {\n            let rnd = Math.random() * remainingWeightSum|0;\n            for (let j=0; j < choiceCount; j += 2)\n            {\n                const weight = choices[j]\n                const tileId = choices[j + 1]\n                rnd -= weight\n\n                if (rnd <= 0)\n                {\n                    //console.log(\"choice = \", tileName(tileDefinitions, tileId))\n                    choice = tileId;\n                    break;\n                }\n            }\n        }\n        //console.log(\"Choose \", tileName(tileDefinitions, choice), \" for \", tileDataIndex / td_size)\n\n        tileData[tileDataIndex + td_tileId ] = choice;\n        tileData[tileDataIndex + td_collapsed ] = 1;\n\n        tileWasCollapsed = true;\n        count--;\n\n        const tileIndex = tileDataIndex * tileFactor;\n\n        // propagate to neighbors\n        for (let j=0; j < 4; j++)\n        {\n            const neighbor = tiles[tileIndex + t_tile0 + j];\n\n            if (neighbor < 0)\n            {\n                continue;\n            }\n\n            //console.log(\"Propagate to \" + neighbor / t_size)\n\n            const neighborTileDataIndex = neighbor * tileDataFactor;\n            const isCollapsed = tileData[neighborTileDataIndex + td_collapsed];\n            if (!isCollapsed)\n            {\n                const ground = tileData[neighborTileDataIndex + td_ground];\n\n                let first = true;\n\n                // let buf = \"\";\n                // let skipBuf = \"\";\n                // let count = 1;\n                for (let k=0; k < 4; k++)\n                {\n                    const connectedTile = tiles[neighbor + t_tile0 + k];\n                    if (connectedTile < 0)\n                    {\n                        continue;\n                    }\n                    const connectedTileDataIndex = connectedTile * tileDataFactor;\n\n                    const isCollapsed = tileData[connectedTileDataIndex + td_collapsed];\n                    let tileId = tileData[connectedTileDataIndex + td_tileId];\n                    if (isCollapsed && tileId !== -1)\n                    {\n\n                        const index = tileId >> 5;\n                        const bit = 1 << (tileId - (index << 5));\n\n\n                        if (!(adjacencies[ground * numEntries + maxId + index] & bit))\n                        {\n                            // if we find a tile on a neighboring layer with different ground that is not allowed\n                            // on our terrain, we just ignore it.\n                            // skipBuf += (\"Skip \" + tileName(tileDefinitions, tileId) + \" on \" + MATERIAL_NAMES[ground]+ \", index = \" + index + \", bit = \" + bit)\n                            // skipBuf += printMask(tileDefinitions, adjacencies, maxId, numInts, ground, tileId)\n\n                            continue;\n                        }\n\n\n                        for (let int=0; int < numInts; int++)\n                        {\n                            const maskValue = adjacencies[ground * numEntries + tileId + int];\n\n                            if (first)\n                            {\n                                tileData[connectedTileDataIndex + td_bitmask + int ] = maskValue;\n\n                                //buf += count++ + \":\" + tileName(tileDefinitions, tileId) + \": Mask = \" + printMask(tileDefinitions, adjacencies, maxId, numInts, ground, tileId) + \"\\n\"\n\n                            }\n                            else\n                            {\n                                tileData[neighborTileDataIndex + td_bitmask + int ] &= maskValue;\n                                //buf += count++ + \":\" + tileName(tileDefinitions, tileId) + \": Mask = \" + printMask(tileDefinitions, adjacencies, maxId, numInts, ground, tileId) + \"\\n\"\n                            }\n                        }\n\n                        first = false;\n                    }\n                }\n\n                let empty = true;\n                for (let int=0; int < numInts; int++)\n                {\n                    if (tileData[neighborTileDataIndex + td_bitmask + int])\n                    {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (empty)\n                {\n                    // console.log(\"No solution for tile \", neighbor / t_size, \" on \" ,MATERIAL_NAMES[ground] , \":\\n\", buf)\n                    // if (skipBuf.length)\n                    // {\n                    //     console.log(\"SKIP:\", skipBuf)\n                    // }\n\n                    tileData[neighborTileDataIndex + td_tileId ] = 0;\n                    tileData[neighborTileDataIndex + td_collapsed ] = 1;\n                }\n                else\n                {\n                    // update entropy\n                    tileData[neighborTileDataIndex + td_entropy] = calculateEntropy(tileData, neighborTileDataIndex, weights, numInts, maxId, ground)\n                }\n            }\n        }\n\n    } while(tileWasCollapsed && count > 0)\n}\n\n","export const LUM_THRESHOLD = 0.03928;\n\nexport const PERCEPTIVE_FACTOR_RED = 0.2126;\nexport const PERCEPTIVE_FACTOR_GREEN = 0.7152;\nexport const PERCEPTIVE_FACTOR_BLUE = 0.0722;\n\nconst colorRegExp = /^(#)?([0-9a-f]+)$/i;\n\nfunction checkColor(color)\n{\n\n    let m;\n    if (typeof color !== \"string\" || !(m = colorRegExp.exec(color)))\n    {\n        return null;\n    }\n    const col = m[2];\n\n    if (col.length === 3)\n    {\n        return {\n            r: parseInt(col[0], 16) / 15,\n            g: parseInt(col[1], 16) / 15,\n            b: parseInt(col[2], 16) / 15\n        };\n    }\n    else if (col.length === 6)\n    {\n        return {\n            r: parseInt(col.substring(0, 2), 16) / 255,\n            g: parseInt(col.substring(2, 4), 16) / 255,\n            b: parseInt(col.substring(4, 6), 16) / 255\n        };\n    }\n    else\n    {\n        return null;\n    }\n}\n\nexport function components(color)\n{\n    let col = checkColor(color);\n    if (!col)\n    {\n        throw new Error(\"Invalid color \" + color);\n    }\n    return col;\n}\n\nfunction gun_luminance(v)\n{\n\n    if (v <= LUM_THRESHOLD)\n    {\n        return v / 12.92\n    }\n    else\n    {\n        return Math.pow(((v + 0.055) / 1.055), 2.4);\n    }\n}\n\nfunction hex(n)\n{\n    const s = n.toString(16);\n\n    return s.length === 1 ? \"0\" + s : s;\n}\n\n// Contrast and luminance calculation follows http://www.w3.org/Translations/WCAG20-de/#contrast-ratiodef\n\nexport function isColor(color)\n{\n    const col = checkColor(color);\n    return col && !isNaN(col.r) && !isNaN(col.g) && !isNaN(col.b);\n}\n\nexport function getLuminance(color)\n{\n    const c = components(color);\n    return PERCEPTIVE_FACTOR_RED * gun_luminance(c.r) + PERCEPTIVE_FACTOR_GREEN * gun_luminance(c.g) + PERCEPTIVE_FACTOR_BLUE * gun_luminance(c.b);\n}\n\nexport function contrast(colorA, colorB)\n{\n    let h;\n    let lum1 = getLuminance(colorA);\n    let lum2 = getLuminance(colorB);\n\n    if (lum1 < lum2)\n    {\n        h = lum1;\n        lum1 = lum2;\n        lum2 = h;\n    }\n\n    const contrast = (lum1 + 0.05) / (lum2 + 0.05);\n\n//        console.debug(\"contrast: %o\", contrast);\n\n    return  contrast;\n}\n\nexport function mix(col1, col2, ratio)\n{\n    const c1 = components(col1);\n    const c2 = components(col2);\n\n    const r = ((c1.r + (c2.r - c1.r) * ratio)    * 255) | 0;\n    const g = ((c1.g + (c2.g - c1.g) * ratio) * 255) | 0;\n    const b = ((c1.b + (c2.b - c1.b) * ratio) * 255) | 0;\n\n    return rgb(r, g, b);\n}\n\n/**\n * Creates a color range between the given colors.\n *\n * @param {string} from     start color\n * @param {string} to       end color\n * @param {number} count    number of colors\n *\n * @return {array} array of RGB colors\n */\nexport function range(from, to, count)\n{\n    const step = 1/(count-1);\n\n    const array = new Array(count);\n\n    for (let i = 0, ratio = 0; i < count; i++, ratio += step)\n    {\n        array[i] = mix(from, to, ratio);\n    }\n    return array;\n}\n\nexport function rgb(r, g, b)\n{\n    return \"#\" + hex(r) + hex(g) + hex(b);\n}\n\nexport function fade(color, opacity)\n{\n    const col = components(color);\n    return \"rgba(\" + col.r + \", \" + col.g + \", \" + col.b + \", \" + opacity + \")\";\n}\n\nexport function bestTextColor(color, darkText = \"#000\", lightText = \"#fff\", contrastLimit = 7)\n{\n    // use dark text only if the contrast to the random color is above the contrast limit, otherwise use light text\n    return contrast(color, darkText) >= contrastLimit ? darkText : lightText\n}\n\n","import raf from \"raf\"\nimport Prando from \"prando\";\nimport SimplexNoise from \"simplex-noise\"\n// noinspection ES6UnusedImports\nimport STYLE from \"./style.css\"\nimport {\n    BufferAttribute,\n    BufferGeometry,\n    CubeCamera,\n    DirectionalLight,\n    DoubleSide,\n    Float32BufferAttribute,\n    FrontSide,\n    Mesh,\n    MeshStandardMaterial,\n    Object3D,\n    PerspectiveCamera,\n    PlaneBufferGeometry,\n    RepeatWrapping,\n    Scene, sRGBEncoding,\n    Vector3,\n    Color,\n    WebGLRenderer, MeshBasicMaterial, WireframeGeometry, LineSegments\n} from \"three\"\n\nimport OrganicQuads, {\n    g_size,\n    g_x,\n    g_y,\n    t_isEdge,\n    t_n0,\n    t_n1,\n    t_n2,\n    t_n3,\n    t_size,\n    t_tile0,\n    t_tile1,\n    t_tile2,\n    t_tile3\n} from \"@fforw/organic-quads\";\nimport loadScene from \"./loadScene\";\nimport { Water } from \"three/examples/jsm/objects/Water.js\";\nimport { Sky } from \"three/examples/jsm/objects/Sky.js\";\n\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport Stats from \"three/examples/jsm/libs/stats.module\";\nimport loadTexture from \"./loadTexture\";\nimport { heightLimit } from \"./heightLimit\";\nimport {\n    CASE_NAMES,\n    FOREST,\n    GRASS,\n    GROUND_COLORS,\n    MATERIAL_NAMES,\n    PHI,\n    SAND,\n    STONE,\n    UNDEFINED,\n    WATER\n} from \"./constants\";\n\nimport prepareTiles, { getMaxId } from \"./editor/prepareTiles\";\nimport inputToWfc, { tileName } from \"./util/inputToWFC\";\nimport { numMaterials } from \"./editor/Grid\";\n\n\n\nimport { dump } from \"./util/dump\";\nimport waveFunctionCollapse from \"./util/waveFunctionCollapse\";\nimport { components } from \"./util/color\";\n\nconst SKY_EFFECT = true;\nconst WATER_EFFECT = false;\nconst HEIGHT_MAP = true;\n\nconst DETAIL = 15;\nconst MAX_HEIGHT = 300;\nconst QUARTER_HEIGHT = MAX_HEIGHT / 4;\nconst NOISE_SCALE_1 = 0.003;\nconst NOISE_SCALE_2 = 0.07;\nconst NOISE_SCALE_3 = 0.0007;\nconst GROUND_NOISE_SCALE = 0.005;\nconst NOISE_RATIO = 0.99;\nconst CLIFF_THRESHOLD = 10;\n\n// size of the outer square around our big hexagon\nconst SIZE = 1500;\n\n//////////////////////////////////////////////////////////////////////\n\nconst NUM_MATERIALS = 7;\n\nconst WATER_LIMIT = 2;\nconst SAND_LIMIT = 5.7;\nconst FOREST_LIMIT = 60;\n\nlet container, stats;\nlet camera, scene, renderer, light;\nlet controls, water;\n\nexport const td_cx = 0;\nexport const td_cy = 1;\nexport const td_walkable = 2;\nexport const td_cut0 = 3;\nexport const td_cut1 = 4;\nexport const td_cut2 = 5;\nexport const td_cut3 = 6;\nexport const td_tileId = 7;\nexport const td_entropy = 8;\nexport const td_collapsed = 9;\nexport const td_ground = 10;\nexport const td_bitmask = 11;\nexport const td_size = 12;\n\nlet tileData;\nlet heightMap;\nlet materials;\n\nfunction updateCentroids()\n{\n    const {graph, tiles} = organicQuads;\n    const {length} = tiles;\n\n    let tileDataPos = 0;\n    for (let i = 0; i < length; i += t_size)\n    {\n        const n0 = tiles[i + t_n0];\n        const n1 = tiles[i + t_n1];\n        const n2 = tiles[i + t_n2];\n        const n3 = tiles[i + t_n3];\n\n        tileData[tileDataPos + td_cx] = (graph[n0 + g_x] + graph[n1 + g_x] + graph[n2 + g_x] + graph[n3 + g_x]) / 4;\n        tileData[tileDataPos + td_cy] = (graph[n0 + g_y] + graph[n1 + g_y] + graph[n2 + g_y] + graph[n3 + g_y]) / 4;\n        tileData[tileDataPos + td_walkable] = 0;\n        tileData[tileDataPos + td_cut0] = -1;\n        tileData[tileDataPos + td_cut1] = -1;\n        tileData[tileDataPos + td_cut2] = -1;\n        tileData[tileDataPos + td_cut3] = -1;\n\n        tileDataPos += td_size;\n    }\n\n}\n\n\nlet organicQuads, envMap;\n\nconst nOffset = Math.random() * 10;\nconst mOffset = Math.random() * 10;\n\nfunction heightFn(x0, z0)\n{\n    const distance = Math.sqrt(x0 * x0 + z0 * z0);\n\n    const w = noise.noise2D(x0 * NOISE_SCALE_3, mOffset + z0 * NOISE_SCALE_3) < 0.1 ? 0 : 0.6\n\n    const limit = heightLimit(1 - distance / (SIZE / 2), w);\n\n    return Math.max(0, (QUARTER_HEIGHT + (noise.noise2D(nOffset + x0 * NOISE_SCALE_1, z0 * NOISE_SCALE_1) * NOISE_RATIO + noise.noise2D(z0 * NOISE_SCALE_2, x0 * NOISE_SCALE_2 ) * (1 - NOISE_RATIO) + w) * QUARTER_HEIGHT) * limit);\n}\n\n\nconst tmpHeight = new Float64Array(5);\n\n\nfunction cutCliffs()\n{\n\n    const {graph, tiles} = organicQuads;\n\n    const {length} = tiles;\n\n    const tileDataFactor = td_size / t_size;\n\n    const tileCuts = [];\n\n    const cutNodes = new Set();\n\n    for (let i = 0; i < length; i += t_size)\n    {\n        // find indizes for connected centroid (values might be -1 if on the edge\n        const tileDataIndex = i * tileDataFactor;\n        const tileDataIndex0 = tiles[i + t_tile0] * tileDataFactor;\n        const tileDataIndex1 = tiles[i + t_tile1] * tileDataFactor;\n        const tileDataIndex2 = tiles[i + t_tile2] * tileDataFactor;\n        const tileDataIndex3 = tiles[i + t_tile3] * tileDataFactor;\n\n        tmpHeight[0] = heightFn(tileData[tileDataIndex], tileData[tileDataIndex + 1])\n\n        tmpHeight[1] =\n            tileDataIndex0 >= 0 ? heightFn(tileData[tileDataIndex0 + td_cx], tileData[tileDataIndex0 + td_cy]) : -1;\n        tmpHeight[2] =\n            tileDataIndex1 >= 0 ? heightFn(tileData[tileDataIndex1 + td_cx], tileData[tileDataIndex1 + td_cy]) : -1;\n        tmpHeight[3] =\n            tileDataIndex2 >= 0 ? heightFn(tileData[tileDataIndex2 + td_cx], tileData[tileDataIndex2 + td_cy]) : -1;\n        tmpHeight[4] =\n            tileDataIndex3 >= 0 ? heightFn(tileData[tileDataIndex3 + td_cx], tileData[tileDataIndex3 + td_cy]) : -1;\n\n        //console.log(\"HEIGHTS\", tmpHeight.slice())\n\n        let cutMask = 0;\n\n        if (tileDataIndex0 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[1]) > CLIFF_THRESHOLD)\n        {\n            cutMask |= 1;\n        }\n\n        if (tileDataIndex1 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[2]) > CLIFF_THRESHOLD)\n        {\n            cutMask |= 2;\n        }\n        if (tileDataIndex2 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[3]) > CLIFF_THRESHOLD)\n        {\n            cutMask |= 4;\n        }\n        if (tileDataIndex3 >= 0 && Math.abs(tmpHeight[0] - tmpHeight[4]) > CLIFF_THRESHOLD)\n        {\n            cutMask |= 8;\n        }\n\n        if (cutMask !== 0)\n        {\n            for (let j = 0; j < 4; j++)\n            {\n                if (cutMask & (1 << j))\n                {\n                    const cut0 = j;\n                    const cut1 = j === 3 ? 0 : j + 1;\n\n                    const heightMapIndex0 = tiles[i + t_n0 + cut0] * heightIndexFactor;\n                    const heightMapIndex1 = tiles[i + t_n0 + cut1] * heightIndexFactor;\n\n                    const height = tmpHeight[0];\n\n                    const node0 = tiles[i + t_n0 + cut0];\n                    const node1 = tiles[i + t_n0 + cut1];\n\n                    cutNodes.add(node0)\n                    cutNodes.add(node1)\n\n                    tileData[tileDataIndex + td_cut0 + cut0] = height;\n                    tileData[tileDataIndex + td_cut0 + cut1] = height;\n\n                    const rnd = Math.random();\n                    if (rnd < 0.2)\n                    {\n                        heightMap[heightMapIndex0 + h_ground] = STONE;\n                    }\n                    else if (rnd < 0.4)\n                    {\n                        heightMap[heightMapIndex1 + h_ground] = STONE;\n                    }\n\n\n                    const other = tiles[i + t_tile0 + j];\n                    // mark our connection to the other tile as cut\n                    tiles[i + t_tile0 + j] = -1;\n\n                    let usInOther = -1;\n                    for (let k = 0; k < 4; k++)\n                    {\n                        if (\n                            tiles[other + t_tile0 + k] === i &&\n                            tileData[other * tileDataFactor + td_cut0 + k] === -1)\n                        {\n                            usInOther = i;\n                            break;\n                        }\n                    }\n                    if (usInOther !== -1)\n                    {\n                        tileCuts.push(0, i, other, cut0, cut1);\n                    }\n                }\n            }\n\n\n            for (let j = 0; j < 4; j++)\n            {\n                if (!(cutMask & (1 << j)))\n                {\n                    const prev = j === 0 ? 3 : j - 1;\n                    const next = j === 3 ? 0 : j + 1;\n\n                    const prevIsCut = cutMask & (1 << prev);\n                    const nextIsCut = cutMask & (1 << next);\n\n                    const other = tiles[i + t_tile0 + j];\n\n                    if (prevIsCut || nextIsCut)\n                    {\n                        if (prevIsCut && nextIsCut)\n                        {\n                            // full cut\n                            tileCuts.push(0, i, other, j, next);\n                        }\n                        else if (prevIsCut)\n                        {\n                            // triangle with two points on prev\n                            tileCuts.push(2, i, other, j, next);\n                        }\n                        else\n                        {\n                            // triangle with two points on next\n                            tileCuts.push(1, i, other, j, next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (let cut of cutNodes)\n    {\n\n        for (let i = 0; i < length; i += t_size)\n        {\n            for (let j = 0; j < 4 ; j++)\n            {\n                const node = tiles[i + t_n0 + j];\n                if (node === cut)\n                {\n                    const tileDataIndex = i * tileDataFactor;\n\n                    if (tileData[tileDataIndex + td_cut0 + j] === -1)\n                    {\n                        tileData[tileDataIndex + td_cut0 + j] = heightFn(tileData[tileDataIndex + td_cx], tileData[tileDataIndex + td_cy])\n                    }\n                }\n            }\n        }\n    }\n\n\n    return tileCuts;\n}\n\nconst tc_case = 0;\nconst tc_tile0 = 1;\nconst tc_tile1 = 2;\nconst tc_cut0 = 3;\nconst tc_cut1 = 4;\nconst tc_size = 5;\n\nexport const h_height = 0;\nexport const h_ground = 1;\nexport const h_cuts = 2;\nexport const h_size = 3;\n\nlet tileCuts;\n\nfunction createScene()\n{\n\n    organicQuads = new OrganicQuads({\n        numberOfRings: DETAIL,\n        width: SIZE,\n        height: SIZE,\n        graphUserData: 1,\n        // weightFunction: (x0,y0,x1,y1) => {\n        //\n        //     const dx = x1 - x0;\n        //     const dy = y1 - y0;\n        //     const dz = heightFn(x0,y0) - heightFn(x1,y1);\n        //\n        //     return Math.sqrt(dx * dx + dy * dy + dz * dz);\n        //\n        // }\n    });\n\n    const {graph, tiles, config} = organicQuads;\n    const {length} = graph;\n\n    const heightMapFactor = h_size / g_size;\n\n    heightMap = new Float64Array(length * heightMapFactor);\n    let pos = 0;\n    for (let i = 0; i < length; i += g_size)\n    {\n        heightMap[pos + h_height] = heightFn(graph[i + g_x], graph[i + g_y]);\n        heightMap[pos + h_ground] = UNDEFINED;\n\n        pos += h_size;\n    }\n\n    tileData = new Float64Array((organicQuads.tiles.length / t_size) * td_size);\n    updateCentroids()\n    tileCuts = cutCliffs()\n\n    console.log({tileCuts: group(tileCuts, tc_size)})\n\n    testWalkability();\n    generateGround();\n\n}\n\n\nfunction generateGround()\n{\n\n    const {graph} = organicQuads;\n    const {length} = graph;\n\n    let heightMapPos = 0;\n    let nodePos = 0;\n    for (let i = 0; i < length; i += g_size)\n    {\n\n        const x0 = graph[nodePos + g_x];\n        const y0 = heightMap[heightMapPos + h_height];\n        //const y0 = heightMap[heightIndex0 + h_height];\n        const z0 = graph[nodePos + g_y];\n\n        const ground = heightMap[heightMapPos + h_ground];\n\n        if (ground === UNDEFINED)\n        {\n            if (y0 < WATER_LIMIT)\n            {\n                heightMap[heightMapPos + h_ground] = WATER;\n            }\n            else if (y0 < SAND_LIMIT)\n            {\n                heightMap[heightMapPos + h_ground] = SAND;\n            }\n            else\n            {\n                const n = noise.noise2D(x0 * GROUND_NOISE_SCALE, z0 * GROUND_NOISE_SCALE);\n\n                if (y0 < FOREST_LIMIT)\n                {\n                    heightMap[heightMapPos + h_ground] = n < 0.2 ? GRASS : FOREST;\n                }\n                else\n                {\n                    heightMap[heightMapPos + h_ground] = n < 0.2 ? FOREST : GRASS;\n                }\n            }\n        }\n\n        heightMapPos += h_size;\n        nodePos += g_size;\n    }\n\n}\n\n\nfunction testWalkability()\n{\n    const tileIndex = findEdgeTile();\n\n    console.log(\"Starting to walk at #\", tileIndex / t_size)\n\n    const visited = new Set();\n    walkRecursive(tileIndex, visited);\n}\n\n\nfunction findEdgeTile()\n{\n    const {tiles} = organicQuads;\n\n    const {length} = tiles;\n\n    for (let i = 0; i < length; i += t_size)\n    {\n        if (tiles[i + t_isEdge])\n        {\n            return i;\n        }\n    }\n    throw new Error(\"No edge!?\")\n}\n\n\nconst tileDataFactor = td_size / t_size;\n\n\nfunction walkRecursive(tileIndex, visited)\n{\n    if (tileIndex >= 0 && !visited.has(tileIndex))\n    {\n        visited.add(tileIndex);\n\n        const {tiles} = organicQuads;\n\n        tileData[tileIndex * tileDataFactor + td_walkable] = 1;\n\n        walkRecursive(tiles[tileIndex + t_tile0], visited);\n        walkRecursive(tiles[tileIndex + t_tile1], visited);\n        walkRecursive(tiles[tileIndex + t_tile2], visited);\n        walkRecursive(tiles[tileIndex + t_tile3], visited);\n\n    }\n}\n\n\nconst rng = new Prando(\"TEST\")\n\nconst noise = new SimplexNoise(() => rng.next());\n\n\nfunction checkNaN(value, msg)\n{\n    if (isNaN(value))\n    {\n        debugger;\n        throw new Error(msg + \": value is NaN\")\n    }\n}\n\n\nconst UNDEFINED_COLOR = components(\"#f0f\");\n\nfunction addHeightMap(tileDefinitions)\n{\n    const geometry = new BufferGeometry();\n    geometry.name = \"Landscape-Debug\"\n\n    const vertices = [];\n    const normals = [];\n    const colors = [];\n\n    const helperVertices = [];\n    const helperNormals = [];\n\n    // generate vertices, normals and color data for a simple grid geometry\n    const { graph, tiles } = organicQuads;\n\n    const { length } = tiles;\n\n    console.log(\"Height map for \", length / t_size, \" tiles\");\n\n    // const map = {};\n    //\n    // const insert = (a,b) => {\n    //     if (a > b)\n    //     {\n    //         let h = a;\n    //         a=b;\n    //         b=h;\n    //     }\n    //\n    //     const key = a + \":\" + b;\n    //\n    //     const v = map[key];\n    //     map[key] =  v === undefined ? 1 : v + 1;\n    // }\n\n    const getColor = (tileDefinitions, tileId) => {\n\n\n        for (let i = 0; i < tileDefinitions.length; i++)\n        {\n            const { id, idCount, colors} = tileDefinitions[i];\n\n            //console.log({id,idCount})\n\n            if (tileId >= id && tileId < id + idCount)\n            {\n                const result = components(colors[tileId - id]);\n                //console.log(\"Find color for \", tileId, \"=>\", result)\n                return result;\n            }\n        }\n\n        console.log(\"No color for \", tileName(tileDefinitions, tileId))\n\n        return UNDEFINED_COLOR;\n    };\n\n    let tileDataIndex = 0;\n    for (let i = 0; i < length; i += t_size)\n    {\n        // node indizes for our quad\n        const n0 = tiles[i + t_n0];\n        const n1 = tiles[i + t_n1];\n        const n2 = tiles[i + t_n2];\n        const n3 = tiles[i + t_n3];\n\n        // const e0 = tiles[i + t_tile0]\n        // const e1 = tiles[i + t_tile1]\n        // const e2 = tiles[i + t_tile2]\n        // const e3 = tiles[i + t_tile3]\n        // e0 >= 0 && insert(i * tileFactor, e0 * tileFactor)\n        // e1 >= 0 && insert(i * tileFactor, e1 * tileFactor)\n        // e2 >= 0 && insert(i * tileFactor, e2 * tileFactor)\n        // e3 >= 0 && insert(i * tileFactor, e3 * tileFactor)\n\n        // equivalent height map indizes\n        const heightIndex0 = n0 * heightIndexFactor;\n        const heightIndex1 = n1 * heightIndexFactor;\n        const heightIndex2 = n2 * heightIndexFactor;\n        const heightIndex3 = n3 * heightIndexFactor;\n\n        const x0 = graph[n0 + g_x];\n        const y0 = tileData[tileDataIndex + td_cut0] === -1 ?\n            heightMap[heightIndex0 + h_height] :\n            tileData[tileDataIndex + td_cut0];\n        //const y0 = heightMap[heightIndex0 + h_height];\n        const z0 = graph[n0 + g_y];\n\n        const x1 = graph[n1 + g_x];\n        const y1 = tileData[tileDataIndex + td_cut1] === -1 ?\n            heightMap[heightIndex1 + h_height] :\n            tileData[tileDataIndex + td_cut1];\n        //const y1 = heightMap[heightIndex1 + h_height];\n        const z1 = graph[n1 + g_y];\n\n        const x2 = graph[n2 + g_x];\n        const y2 = tileData[tileDataIndex + td_cut2] === -1 ?\n            heightMap[heightIndex2 + h_height] :\n            tileData[tileDataIndex + td_cut2];\n        //const y2 = heightMap[heightIndex2 + h_height]\n        const z2 = graph[n2 + g_y];\n\n        const x3 = graph[n3 + g_x];\n        const y3 = tileData[tileDataIndex + td_cut3] === -1 ?\n            heightMap[heightIndex3 + h_height] :\n            tileData[tileDataIndex + td_cut3];\n        //const y3 = heightMap[heightIndex3 + h_height];\n        const z3 = graph[n3 + g_y];\n\n        const ax = (x0 - x1);\n        const ay = (y0 - y1);\n        const az = (z0 - z1);\n        const bx = (x2 - x1);\n        const by = (y2 - y1);\n        const bz = (z2 - z1);\n        const cx = (x3 - x1);\n        const cy = (y3 - y1);\n        const cz = (z3 - z1);\n\n        // normal vector based on points 0, 1 and 2\n        const n0x = ay * bz - az * by;\n        const n0y = az * bx - ax * bz;\n        const n0z = ax * by - ay * bx;\n\n        // normal vector based on points 0, 1 and 3\n        const n1x = ay * cz - az * cy;\n        const n1y = az * cx - ax * cz;\n        const n1z = ax * cy - ay * cx;\n\n        // average and renormalize\n        let nx = (n0x + n1x) / 2;\n        let ny = (n0y + n1y) / 2;\n        let nz = (n0z + n1z) / 2;\n\n        const f = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n        nx *= f;\n        ny *= f;\n        nz *= f;\n\n        // const cf = 4 / MAX_HEIGHT;\n        //\n        // colors.push( y3 * cf,1 - y3 * cf, 0);\n        // colors.push( y1 * cf,1 - y1 * cf, 0);\n        // colors.push( y1 * cf,1 - y1 * cf, 0);\n        // colors.push( y3 * cf,1 - y3 * cf, 0);\n        // colors.push( y2 * cf,1 - y2 * cf, 0);\n\n        const ground0 = heightMap[heightIndex0 + h_ground];\n        const ground1 = heightMap[heightIndex1 + h_ground];\n        const ground2 = heightMap[heightIndex2 + h_ground];\n        const ground3 = heightMap[heightIndex3 + h_ground];\n\n        if (\n            !(ground0 === WATER &&\n              ground1 === WATER &&\n              ground2 === WATER &&\n              ground3 === WATER)\n        )\n        {\n            vertices.push(x0, y0, z0);\n            vertices.push(x3, y3, z3);\n            vertices.push(x1, y1, z1);\n\n            vertices.push(x1, y1, z1);\n            vertices.push(x3, y3, z3);\n            vertices.push(x2, y2, z2);\n\n            normals.push(nx, ny, nz);\n            normals.push(nx, ny, nz);\n            normals.push(nx, ny, nz);\n\n            normals.push(nx, ny, nz);\n            normals.push(nx, ny, nz);\n            normals.push(nx, ny, nz);\n\n\n            const col = getColor(tileDefinitions, tileData[tileDataIndex + td_tileId])\n\n            // colors.push(color0[0], color0[1], color0[2]);\n            // colors.push(color3[0], color3[1], color3[2]);\n            // colors.push(color1[0], color1[1], color1[2]);\n            //\n            // colors.push(color1[0], color1[1], color1[2]);\n            // colors.push(color3[0], color3[1], color3[2]);\n            // colors.push(color2[0], color2[1], color2[2]);\n\n\n            colors.push(col.r, col.g, col.b);\n            colors.push(col.r, col.g, col.b);\n            colors.push(col.r, col.g, col.b);\n\n            colors.push(col.r, col.g, col.b);\n            colors.push(col.r, col.g, col.b);\n            colors.push(col.r, col.g, col.b);\n\n            // const mx = (x3 + x2) / 2;\n            // const my = (y3 + y2) / 2;\n            // const mz = (z3 + z2) / 2;\n            //\n            // helperVertices.push(\n            //     (x1 + x0) / 2, (y1 + y0) / 2,(z1 + z0) / 2,\n            //     (x3 + mx) / 2, (y3 + my) / 2,(z3 + mz) / 2,\n            //     (x2 + mx) / 2, (y2 + my) / 2,(z2 + mz) / 2\n            // )\n            //\n            // helperNormals.push(nx, ny, nz);\n            // helperNormals.push(nx, ny, nz);\n            // helperNormals.push(nx, ny, nz);\n\n        }\n\n        tileDataIndex += td_size;\n\n    }\n\n    //const values = Object.values(map);\n    //console.log(\"SYMMETRY-CHECK\", map, values.filter(n => n === 1).length, \"of\", values.length);\n\n    //console.log(\"MAX DELTA\", max);\n\n    //\n    //console.log({vertices, normals, colors})\n\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n\n    const material = new MeshStandardMaterial({\n        vertexColors: true,\n        side: DoubleSide,\n        roughness: 0.5\n    });\n    const mesh = new Mesh(geometry, material);\n    mesh.position.set(0, -WATER_LIMIT, 0);\n    scene.add(mesh);\n\n    // const wireframe = new WireframeGeometry( geometry );\n    //\n    // const line = new LineSegments( wireframe );\n    // line.material.depthTest = false;\n    // line.material.color = new Color(\"#000\");\n    // line.material.opacity = 0.25;\n    // line.material.transparent = true;\n    // scene.add( line );\n\n    if (helperVertices.length > 0)\n    {\n        const geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", new BufferAttribute(new Float32Array(helperVertices), 3, false));\n        geometry.setAttribute(\"normal\", new BufferAttribute(new Float32Array(helperNormals), 3, false));\n\n        const mesh = new Mesh(\n            geometry,\n            new MeshBasicMaterial({\n                color: new Color(\"#f0f\"),\n                depthTest: false,\n                // opacity: 0.2,\n                // transparent: true\n            })\n        )\n\n        scene.add(mesh);\n\n    }\n\n}\n\n\nconst skyParameters = {\n    distance: 1000,\n    inclination: 0.1,\n    azimuth: 0.1\n};\n\n\nfunction updateSun()\n{\n\n    if (!sky)\n    {\n        return;\n    }\n\n    const theta = Math.PI * (skyParameters.inclination - 0.5);\n    const phi = 2 * Math.PI * (skyParameters.azimuth - 0.5);\n\n    light.position.x = skyParameters.distance * Math.cos(phi);\n    light.position.y = skyParameters.distance * Math.sin(phi) * Math.sin(theta);\n    light.position.z = skyParameters.distance * Math.sin(phi) * Math.cos(theta);\n\n    sky.material.uniforms[\"sunPosition\"].value = light.position.copy(light.position);\n    water && water.material.uniforms[\"sunDirection\"].value.copy(light.position).normalize();\n\n    cubeCamera.update(renderer, sky);\n\n}\n\n\nlet cubeCamera, sky;\n\n\n\n\n\nfunction init()\n{\n\n    createScene();\n\n    container = document.getElementById(\"container\");\n\n    //\n\n    renderer = new WebGLRenderer();\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.outputEncoding = sRGBEncoding\n    container.appendChild(renderer.domElement);\n\n    //\n\n    scene = new Scene();\n\n    camera = new PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);\n    camera.position.set(250, 250, 1000);\n\n    //\n\n    light = new DirectionalLight(\"#fff8d5\", 0.8);\n    scene.add(light);\n\n    cubeCamera = new CubeCamera(0.2, 1, 512);\n    // cubeCamera.renderTarget.texture.generateMipmaps = true;\n    // cubeCamera.renderTarget.texture.minFilter = LinearMipmapLinearFilter;\n\n    scene.background = cubeCamera.renderTarget;\n\n    // Water\n\n    const waterGeometry = new PlaneBufferGeometry(30000, 30000);\n    if (WATER_EFFECT)\n    {\n        water = new Water(\n            waterGeometry,\n            {\n                textureWidth: 512,\n                textureHeight: 512,\n                waterNormals,\n                alpha: 0.6,\n                sunDirection: light.position.clone().normalize(),\n                sunColor: \"#fff8d5\",\n                waterColor: \"#000e1e\",\n                distortionScale: 2.5,\n                clipBias: 0.0001,\n                fog: true\n            }\n        );\n        water.rotation.x = -Math.PI / 2;\n        scene.add(water);\n    }\n    else\n    {\n        const material = new MeshStandardMaterial({\n            side: FrontSide,\n            color: \"#00232a\",\n            envMap: cubeCamera.renderTarget.texture,\n            roughness: 0.2\n        });\n\n        const mesh = new Mesh(waterGeometry, material);\n        mesh.rotation.x = -Math.PI / 2;\n        //scene.add(mesh)\n    }\n\n    // Skybox\n\n    if (SKY_EFFECT)\n    {\n        sky = new Sky();\n\n\n        // uniforms[\"turbidity\"].value = 5;\n        // uniforms[\"rayleigh\"].value = 1.2;\n        // uniforms[\"luminance\"].value = 1;\n        // uniforms[\"mieCoefficient\"].value = 0.05;\n        // uniforms[\"mieDirectionalG\"].value = 0.9;\n\n        envMap = cubeCamera.renderTarget.texture\n\n        updateSun();\n    }\n    else\n    {\n        envMap = null;\n    }\n\n    controls = new OrbitControls(camera, renderer.domElement);\n    //controls.maxPolarAngle = Math.PI * 0.45;\n    controls.maxPolarAngle = Math.PI;\n    controls.target.set(0, 0, 0);\n    controls.minDistance = 0.0;\n    controls.maxDistance = 1500.0;\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.02;\n    controls.update();\n\n    // stats = new Stats();\n    // container.appendChild( stats.dom );\n\n    // GUI\n\n    //const gui = new GUI();\n\n    // const folder = gui.addFolder( \"Sky\" );\n    // folder.add( skyParameters, \"inclination\", 0, 0.5, 0.0001 ).onChange( updateSun );\n    // folder.add( skyParameters, \"azimuth\", 0, 1, 0.0001 ).onChange( updateSun );\n    // folder.open();\n    //\n    // const uniforms = water.material.uniforms;\n    //\n    // const folder = gui.addFolder( \"Water\" );\n    // folder.add( uniforms.distortionScale, \"value\", 0, 8, 0.1 ).name( \"distortionScale\" );\n    // folder.add( uniforms.size, \"value\", 0.1, 10, 0.1 ).name( \"size\" );\n    // folder.add( uniforms.alpha, \"value\", 0.9, 1, .001 ).name( \"alpha\" );\n    // folder.open();\n\n    window.addEventListener(\"resize\", onWindowResize, false);\n\n    ////////////////\n\n    const tileDefinitions = prepareTiles(\n        null // no thumbnails please\n    );\n\n    waveFunctionCollapse(organicQuads, heightMap, tileData, tileDefinitions)\n\n    if (HEIGHT_MAP)\n    {\n        addHeightMap(tileDefinitions);\n    }\n    else\n    {\n        addMarchingSquareObjects(marchingSquaresArray);\n    }\n}\n\n\n\n\n\nlet materialCompile = 0;\nlet materialGenerate = 0;\n\nconst dummy = new Object3D();\n\nfunction addMarchingSquareObjects(marchingSquaresArray)\n{\n\n    const vertexMap = new Map();\n    let vertexCount = 0;\n\n    const position = [];\n    const uv = [];\n    const normal = [];\n\n    const insert = (x,y,z, nx, ny, nz, u, v) => {\n\n\n        x = Math.round(x*16)/16;\n        y = Math.round(y*16)/16;\n        z = Math.round(z*16)/16;\n\n        nx = Math.round(nx*1024)/1024;\n        ny = Math.round(ny*1024)/1024;\n        nz = Math.round(nz*1024)/1024;\n\n        u = Math.round(u*4096)/4096;\n        v = Math.round( v*4096)/4096;\n\n        // const key = ((x*10)|0) + \",\" + ((y*10)|0) + \",\" + ((z*10)|0) + \"/\" +\n        //             ((nx*e)|0) + \":\" + ((ny*1000)|0) + \":\" + ((nz*1000)|0) + \"/\" +\n        //             ((u*4096)|0) + \":\" + ((v*4096)|0);\n\n        const key = x + \",\" + y + \",\" + z + \"/\" + nx + \",\" + ny + \",\" + nz + \"/\" + u  + \",\" + v;\n\n        const index = vertexMap.get(key);\n        if (index === undefined)\n        {\n            const newIndex = vertexCount++;\n            vertexMap.set(key, newIndex);\n\n            position.push(x,y,z);\n            uv.push(u,v);\n            normal.push(nx,ny,nz);\n\n            return newIndex;\n        }\n        return index;\n    }\n\n\n    const facesByMaterial = new Array(NUM_MATERIALS);\n\n    for (let currGround = WATER + 1; currGround < NUM_MATERIALS; currGround++)\n    {\n        const array = createMarchingSquares(currGround, insert, marchingSquaresArray);\n        if (array.length)\n        {\n            facesByMaterial[currGround] = array;\n        }\n    }\n\n    const { graph, tiles } = organicQuads;\n\n    let faces = facesByMaterial[STONE];\n    if (!faces)\n    {\n        faces = facesByMaterial[STONE] = [];\n    }\n\n    let tileDataIndex = 0;\n    for (let i = 0; i < tileCuts.length; i += tc_size)\n    {\n        const cutCase = tileCuts[i + tc_case];\n        const tileA = tileCuts[i + tc_tile0];\n        const tileB = tileCuts[i + tc_tile1];\n        const cut0 = tileCuts[i + tc_cut0];\n        const cut1 = tileCuts[i + tc_cut1];\n\n        const tileDataIndexA = tileA * tileDataFactor;\n        const tileDataIndexB = tileB * tileDataFactor;\n\n        let otherCut0 = -1, otherCut1 = -1\n\n        let node0 = tiles[tileA + t_n0 + cut0];\n        let node1 = tiles[tileA + t_n0 + cut1];\n\n        for (let k = 0; k < 4; k++)\n        {\n            if (tiles[tileB + t_n0 + k] === node0)\n            {\n                otherCut0 = k;\n                if (otherCut1 !== -1)\n                {\n                    break;\n                }\n            }\n            else if (tiles[tileB + t_n0 + k] === node1)\n            {\n                otherCut1 = k;\n                if (otherCut0 !== -1)\n                {\n                    break;\n                }\n            }\n        }\n\n        if (otherCut0 !== -1 && otherCut1 !== -1)\n        {\n            const x0 = graph[node0 + g_x];\n            const y0 = tileData[tileDataIndexA + td_cut0 + cut0]\n            const z0 = graph[node0 + g_y];\n\n            const x1 = graph[node1 + g_x];\n            const y1 = tileData[tileDataIndexA + td_cut0 + cut1]\n            const z1 = graph[node1 + g_y];\n\n            const x3 = x0;\n            const y3 = tileData[tileDataIndexB + td_cut0 + otherCut0]\n            const z3 = z0;\n\n            const x2 = x1;\n            const y2 = tileData[tileDataIndexB + td_cut0 + otherCut1]\n            const z2 = z1;\n\n\n            switch(cutCase)\n            {\n                case 0:\n                {\n                    const ax = (x0 - x1);\n                    const ay = (y0 - y1);\n                    const az = (z0 - z1);\n                    const bx = (x2 - x1);\n                    const by = (y2 - y1);\n                    const bz = (z2 - z1);\n\n                    // normal vector based on points 0, 1 and 2\n                    const nx = ay * bz - az * by;\n                    const ny = az * bx - ax * bz;\n                    const nz = ax * by - ay * bx;\n\n                    const indexA = insert(x0,y0,z0, nx,ny,nz, 0,0);\n                    const indexB = insert(x1,y1,z1, nx,ny,nz, 0,1);\n                    const indexC = insert(x2,y2,z2, nx,ny,nz, 1,1);\n                    const indexD = insert(x3,y3,z3, nx,ny,nz, 1,0);\n\n\n                    faces.push(indexB, indexA, indexC)\n                    faces.push(indexC, indexA, indexD)\n                    break;\n                }\n                case 1:\n                {\n                    const ax = (x0 - x1);\n                    const ay = (y0 - y1);\n                    const az = (z0 - z1);\n                    const bx = (x2 - x1);\n                    const by = (y2 - y1);\n                    const bz = (z2 - z1);\n\n                    // normal vector based on points 0, 1 and 2\n                    const nx = ay * bz - az * by;\n                    const ny = az * bx - ax * bz;\n                    const nz = ax * by - ay * bx;\n\n                    const indexA = insert(x0,y0,z0, nx,ny,nz, 0,0);\n                    const indexB = insert(x1,y1,z1, nx,ny,nz, 0,1);\n                    const indexC = insert(x2,y2,z2, nx,ny,nz, 1,1);\n\n                    faces.push(indexA, indexB, indexC)\n                    break;\n                }\n                case 2:\n                {\n                    const ax = (x0 - x3);\n                    const ay = (y0 - y3);\n                    const az = (z0 - z3);\n                    const bx = (x2 - x3);\n                    const by = (y2 - y3);\n                    const bz = (z2 - z3);\n\n                    // normal vector based on points 0, 1 and 2\n                    const nx = ay * bz - az * by;\n                    const ny = az * bx - ax * bz;\n                    const nz = ax * by - ay * bx;\n\n                    const indexA = insert(x0,y0,z0, nx,ny,nz, 0,0);\n                    const indexC = insert(x2,y2,z2, nx,ny,nz, 1,1);\n                    const indexD = insert(x3,y3,z3, nx,ny,nz, 1,0);\n\n                    faces.push(indexA, indexC, indexD)\n\n                    break;\n                }\n            }\n\n        }\n        else\n        {\n            console.log(\"No two cuts for\", tileA, tileB, \"=>\", otherCut0, otherCut1)\n        }\n\n\n    }\n\n    //console.log({facesByMaterial, position, normal, uv});\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new BufferAttribute(new Float32Array(position), 3, false));\n    geometry.setAttribute(\"normal\", new BufferAttribute(new Float32Array(normal), 3, false));\n    geometry.setAttribute(\"uv\", new BufferAttribute(new Float32Array(uv), 2, false));\n\n    let start = 0;\n    const meshMaterials = [];\n\n    let index = [];\n\n    for (let i = 0; i < facesByMaterial.length; i++)\n    {\n        const faces = facesByMaterial[i];\n        if (faces)\n        {\n            index = index.concat(faces);\n\n            const numTris = faces.length;\n            //console.log(\"geometry.addGroup(\",start, numTris, meshMaterials.length,\")\");\n            geometry.addGroup(start, numTris, meshMaterials.length);\n\n            meshMaterials.push(\n                materials[i].clone()\n            )\n\n            start += numTris;\n        }\n    }\n\n    geometry.setIndex(index);\n\n    const terrain = new Mesh(geometry, meshMaterials);\n    scene.add(terrain);\n}\n\nconst heightIndexFactor = h_size / g_size;\n\nconst pos = new Vector3();\nconst vX1 = new Vector3();\nconst vX2 = new Vector3();\nconst vY1 = new Vector3();\n\nconst vAxisStart = new Vector3();\nconst vAxisEnd = new Vector3();\nconst transformed = new Vector3();\nconst normal = new Vector3();\nconst vUp = new Vector3();\n\nfunction createMarchingSquares(ground, insert, marchingSquaresArray)\n{\n    const {graph, tiles} = organicQuads;\n\n    const {length} = tiles;\n\n    const faces = [];\n    let tileDataIndex = 0;\n    for (let i = 0; i < length; i += t_size)\n    {\n        // node indizes for our quad\n        const n0 = tiles[i + t_n0];\n        const n1 = tiles[i + t_n1];\n        const n2 = tiles[i + t_n2];\n        const n3 = tiles[i + t_n3];\n\n        // equivalent height map indizes\n        const heightIndex0 = n0 * heightIndexFactor;\n        const heightIndex1 = n1 * heightIndexFactor;\n        const heightIndex2 = n2 * heightIndexFactor;\n        const heightIndex3 = n3 * heightIndexFactor;\n\n        // const centroidX = tileData[tileDataIndex + td_cx];\n        // const centroidY = heightFn(tileData[tileDataIndex + td_cx], tileData[tileDataIndex + td_cy]);\n        // const centroidZ = tileData[tileDataIndex + td_cy];\n\n        const x0 = graph[n0 + g_x];\n        const y0 = tileData[tileDataIndex + td_cut0] === -1 ?\n            heightMap[heightIndex0 + h_height] :\n            tileData[tileDataIndex + td_cut0];\n        const z0 = graph[n0 + g_y];\n\n        const x1 = graph[n1 + g_x];\n        const y1 = tileData[tileDataIndex + td_cut1] === -1 ?\n            heightMap[heightIndex1 + h_height] :\n            tileData[tileDataIndex + td_cut1];\n        const z1 = graph[n1 + g_y];\n\n        const x2 = graph[n2 + g_x];\n        const y2 = tileData[tileDataIndex + td_cut2] === -1 ?\n            heightMap[heightIndex2 + h_height] :\n            tileData[tileDataIndex + td_cut2];\n        const z2 = graph[n2 + g_y];\n\n        const x3 = graph[n3 + g_x];\n        const y3 = tileData[tileDataIndex + td_cut3] === -1 ?\n            heightMap[heightIndex3 + h_height] :\n            tileData[tileDataIndex + td_cut3];\n        const z3 = graph[n3 + g_y];\n\n        const ax = (x0 - x1);\n        const ay = (y0 - y1);\n        const az = (z0 - z1);\n        const bx = (x2 - x1);\n        const by = (y2 - y1);\n        const bz = (z2 - z1);\n        const cx = (x3 - x1);\n        const cy = (y3 - y1);\n        const cz = (z3 - z1);\n\n        // normal vector based on points 0, 1 and 2\n        const n0x = ay * bz - az * by;\n        const n0y = az * bx - ax * bz;\n        const n0z = ax * by - ay * bx;\n\n        // normal vector based on points 0, 1 and 3\n        const n1x = ay * cz - az * cy;\n        const n1y = az * cx - ax * cz;\n        const n1z = ax * cy - ay * cx;\n\n        // average with world up and renormalize\n        let upX = (n0x + n1x) / 3;\n        let upY = (n0y + n1y + 1) / 3;\n        let upZ = (n0z + n1z) / 3;\n\n        const f = 1 / Math.sqrt(upX * upX + upY * upY + upZ * upZ);\n        upX *= f;\n        upY *= f;\n        upZ *= f;\n\n        const g1 = heightMap[heightIndex0 + h_ground];\n        const g2 = heightMap[heightIndex3 + h_ground];\n        const g4 = heightMap[heightIndex2 + h_ground];\n        const g8 = heightMap[heightIndex1 + h_ground];\n\n        let tileCase = (\n            ( g1 === ground ? 1 : 0) +\n            ( g2 === ground ? 2 : 0) +\n            ( g4 === ground ? 4 : 0) +\n            ( g8 === ground ? 8 : 0)\n        );\n\n\n        if (tileCase !== 0)\n        {\n            // fix multi-color gaps\n            if (tileCase === 1 && g2 !== g8)\n            {\n                tileCase = 16;\n            }\n            else if (tileCase === 2 && g4 !== g1)\n            {\n                tileCase = 17;\n            }\n            else if (tileCase === 4 && g8 !== g2)\n            {\n                tileCase = 18;\n            }\n            else if (tileCase === 8 && g1 !== g4)\n            {\n                tileCase = 19;\n            }\n\n            if (tileCase === 5 && (g1 === GRASS || g1 === STONE))\n            {\n                tileCase = 20;\n            }\n\n            if (tileCase === 10 && (g2 === GRASS || g2 === STONE))\n            {\n                tileCase = 21;\n            }\n\n            pos.set(x0, y0, z0);\n            vX1.set(x3 - x0, y3 - y0, z3 - z0);\n            vX2.set(x2 - x1, y2 - y1, z2 - z1);\n            vY1.set(x1 - x0, y1 - y0, z1 - z0);\n\n            const geo = marchingSquaresArray[tileCase];\n\n            const index = geo.getIndex().array;\n            const positions = geo.getAttribute(\"position\").array;\n            const uvs = geo.getAttribute(\"uv\").array;\n            const normals = geo.getAttribute(\"normal\").array;\n\n            //console.log({index, positions, normals, uvs})\n\n            for (let j = 0; j < index.length; j ++)\n            {\n                const k = index[j];\n\n                const idx = k * 3;\n                const uvIdx = k * 2;\n\n                const x = (positions[idx] + 0.5)* 1.01;\n                const y = (positions[idx + 1]+ 0.5)* 1.01;\n                const z = (positions[idx + 2]+ 0.5) * 1.01;\n\n                const nx = normals[idx];\n                const ny = normals[idx + 1];\n                const nz = normals[idx + 2];\n\n                vAxisStart.copy(vX1).multiplyScalar(x).add(pos);\n                vAxisEnd.copy(vX2).multiplyScalar(x).add(pos).add(vY1);\n\n                vUp.set(upX, upY, upZ).multiplyScalar(z)\n                transformed.copy(vAxisEnd).sub(vAxisStart).multiplyScalar(y).add(vAxisStart).add(vUp);\n\n                // so we act for a moment as if our normal vector was an actual position above the face and we transform\n                // that point just like the geometry\n                vAxisStart.copy(vX1).multiplyScalar(x + nx).add(pos);\n                vAxisEnd.copy(vX2).multiplyScalar(x + nx).add(pos).add(vY1);\n\n                vUp.set(upX, upY, upZ).multiplyScalar(z + nz)\n                normal.copy(vAxisEnd).sub(vAxisStart).multiplyScalar(y + ny).add(vAxisStart).add(vUp);\n\n                //  and then we substract the projected vertex and renormalize because our space is warped.\n                normal.sub(transformed).normalize();\n\n                faces.push(\n                    insert(\n                    transformed.x,\n                    transformed.y,\n                    transformed.z,\n                    normal.x,\n                    normal.y,\n                    normal.z,\n                    uvs[uvIdx],\n                    uvs[uvIdx + 1]\n                ))\n            }\n        }\n\n        tileDataIndex += td_size;\n    }\n    return faces;\n}\n\n\nfunction onWindowResize()\n{\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n\n}\n\n\nlet inclinationCount = 0;\n\n\nfunction mainLoop()\n{\n\n    render();\n    //stats.update();\n\n    //skyParameters.inclination = -0.012 + Math.sin(inclinationCount += 0.01) * 0.524;\n\n    updateSun();\n\n    controls.update()\n    raf(mainLoop);\n\n}\n\n\nlet first = true;\n\nfunction render()\n{\n\n    const time = performance.now() * 0.0001;\n\n    // sphere.position.y = Math.sin( time ) * 5 + 1;\n    // sphere.rotation.x = time * 0.5;\n    // sphere.rotation.z = time * 0.51;\n\n    if (water)\n    {\n        water.position.y = WATER_LIMIT - 0.1 + Math.sin(time) * 0.4;\n        water.material.uniforms[\"time\"].value += 1.0 / 60.0;\n    }\n\n    renderer.render(scene, camera);\n\n    if(first)\n    {\n        //console.log({materialCompile})\n    }\n\n    first = false;\n}\n\n\nlet waterNormals, marchingSquaresArray;\n\n\nfunction extractMarchingSquares(scene)\n{\n    const {children} = scene;\n\n    const array = new Array(CASE_NAMES.length);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const kid = children[i];\n\n        const index = CASE_NAMES.indexOf(kid.name);\n        if (index >= 0)\n        {\n            array[index] = kid.geometry;\n        }\n    }\n    return array;\n}\n\n\n\nPromise.all([\n    loadScene(\"assets/tiles.glb\"),\n    loadScene(\"assets/ground.glb\"),\n    loadScene(\"assets/ms.glb\"),\n    //loadScene(\"assets/ms-raised.glb\"),\n    loadTexture(\"assets/waternormals.jpg\")\n])\n    .then(([\n               _tiles,\n               ground,\n               marchingSquares,\n               //marchingSquaresRaised,\n               tWaterNormals\n           ]) => {\n\n        //scene.add( tiles.scene );\n\n\n        dump( ground.scene, \"tiles: \")\n\n        materials = MATERIAL_NAMES.map(n => {\n            return ground.scene.children.find(kid => kid.name === n).material;\n        })\n\n        marchingSquaresArray = extractMarchingSquares(marchingSquares.scene);\n\n        //console.log(\"INDEXED\", marchingSquaresArray.map(ms => ({index:ms.index,attributes: ms.attributes})))\n\n        //const msMapRaised = extractMarchingSquares(marchingSquaresRaised.scene);\n        // console.log({marchingSquaresArray, msMapRaised})\n\n        //dump(marchingSquares.scene, \"ms-normal: \");\n        //dump(marchingSquaresRaised.scene, \"ms-raised: \");\n\n\n        // console.log(\"Scene Objects\", tiles.scene.children.map(kid => kid.name).join(\", \"))\n        //\n        // const obj  = tiles.scene.children.find(\n        //     kid => kid.name === \"tree_default\"\n        // );\n\n        tWaterNormals.wrapS = tWaterNormals.wrapT = RepeatWrapping;\n        waterNormals = tWaterNormals;\n\n        // tiles.animations; // Array<AnimationClip>\n        // tiles.scene; // Group\n        // tiles.scenes; // Array<Group>\n        // tiles.cameras; // Array<Camera>\n        // tiles.asset; // Object\n\n        // ReactDOM.render(\n        //     <Game/>,\n        //     document.getElementById(\"root\")\n        // )\n\n        init();\n        mainLoop();\n    })\n\n\n\nfunction group(array, count)\n{\n    const out = new Array(array.length / count);\n    for (let i = 0; i < out.length; i++)\n    {\n        out[i] = array.slice(i * count, i * count + count );\n    }\n\n    return out;\n}\n\n","export function dump(obj, level = \"\")\n{\n    const {type} = obj;\n    if (type === \"Group\")\n    {\n        console.log(level + \"GROUP\", obj.name)\n\n        const nextLevel = level + \"    \"\n\n        const {children} = obj;\n        for (let i = 0; i < children.length; i++)\n        {\n            dump(children[i], nextLevel);\n        }\n    }\n    else if (type === \"Mesh\")\n    {\n        console.log(level + \"MESH\", obj.name)\n    }\n}\n"],"sourceRoot":""}